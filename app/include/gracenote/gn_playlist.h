/*
 * Copyright (c) 2005 Gracenote.
 *
 * This software may not be used in any way or distributed without
 * permission. All rights reserved.
 *
 * Some code herein may be covered by US and international patents.
 */

/*
 * gn_playlist.h
 *
 * These APIs should be used by emms with playlist enabled libraries.
 */


#ifndef _GN_PLAYLIST_H_
#define _GN_PLAYLIST_H_

/*
 * Dependencies.
 */

#include	"gn_defines.h"

#include    "gn_playlist_enums.h"
#include    "gn_playlist_types.h"	/* for gnplaylist_entrydata_t and all other playlist data types */

#include    "gn_lookup_defs.h"
#include	"gn_lists.h"
#include	"gn_album_track_types.h"
#include	"gn_ext_data.h"

#include	"gn_genre.h"

#if defined(GN_TEXTID)
#include	"gn_textid_lookup.h"	/* for gn_textid_presult_data_t */
#endif

#ifdef __cplusplus
extern "C"{
#endif


#define  g_gnpl_pl_results  gn_get_playlist_results()

/*
 * Prototypes.
 */

/*
	The APIs below are organized into sections which roughly correspond
	to the Gracenote Embedded MMS SDK Library Reference Manual.

	Music Collections
	
	Playlist Data Base (MLDB)
		Populating the MLDB
		Setting MLDB Entry Data
		Modifying MLDB Entry Data
		Browsing the MLDB
		MLDB Management
	
	Playlist Generators
		Creating and Destroying Generators
		Generator Attribute Access
		Generator Lists

	Generation Criteria
		Creating and Destroying Criteria
		Criterion Attribute Access
		Criterion Management
	
	Limits and Ranking
		Setting Playlist Limits
		Setting Per-Field Limits
		Defining Ranking Criteria
		Managing Ranking Criteria

	Generating Playlists
		Generating Playlists from a Generator
		Generating "More Like This" Playlists
	
	Managing Playlist Generation Results
*/


/*	------------------------------------------------------------------------------------------
 *	MARK:	Music Collections
 *
 *	The Playlist subsystem operates on one or more music collections, each representing a set
 *	of individual tracks forming a coherent unit. 
 */

/*	gnplaylist_create_collection_id
 *
 *	Makes the eMMS library aware of a user defined music collection, reserves an
 *	ID for that collection and hands that ID back to the caller. This function
 *	may also create database files for the metadata local database, MLDB. This
 *	database stores Gracenote Playlist metadata associated with songs in the
 *	collection which are identified by Gracenote technology.
 *
 *	The music collection is not defined by eMMS. It could refer to the music
 *	files on an MP3 player, the music files in a directory tree on a hard drive,
 *	etc.
 *
 *	A music collection should only be registered once. The returned ID is
 *	persistent across calls to gninit_shutdown_emms() and gninit_initialize_emms().
 *
 *	Parameters
 *		collection_id:		An identifier, generated by this function, which is
 *							reserved for the music collection being registered.
 */
gn_error_t
gnplaylist_create_collection_id(
	gn_collection_id_t	*collection_id
	);


/*	gnplaylist_delete_collection_id
 *
 *	Removes the association between the given collection ID and the user music
 *	collection with which it was associated.
 *
 *	This function also deletes MLDB entries for songs in that collection which
 *	have been identified and added, and will delete any MLDB database files
 *	which are left empty by that operation.
 *
 *	After this function has been called, the given ID is available to associate
 *	with a new music collection. That is, the given ID may be assigned by a
 *	subsequent call to gnplaylist_create_collection_id().
 *
 *	Parameters
 *		collection_id:		The identifier for the music collection to be unregistered.
 *							This is the value returned by gnplaylist_create_collection_id()
 *							for the collection.
 */
gn_error_t
gnplaylist_delete_collection_id(
	gn_collection_id_t	collection_id
	);


/*	gnplaylist_open_collection_id
 *
 *	Makes the metadata associated with a previously registered music collection
 *	available to the playlist subsystem.
 *
 *	This information is not persistent across calls to gninit_shutdown_emms()
 *	and gninit_initialize_emms(). After calling gninit_initialize_emms() no
 *	collection IDs will be enabled until this function is called.
 *
 *	Making a collection ID available for playlist generation does not mean the
 *	associated metadata will be used for playlist generation. The flexibility to
 *	include the metadata associated with a collection in playlist generation is
 *	provided by gnplaylist_enable_for_playlisting().
 *
 *	Parameters
 *		collection_id:		The identifier for the music collection associated with the
 *							metadata to be enabled. This is the value returned by
 *							gnplaylist_create_collection_id().
 */
gn_error_t
gnplaylist_open_collection_id(
	gn_collection_id_t	collection_id
	);


/*	gnplaylist_close_collection_id
 *
 *	Makes previously enabled metadata unavailable to the playlist subsystem.
 *
 *	This function will also call to gnplaylist_disable_for_playlisting(), if
 *	necessary.
 *
 *	During system shutdown, i.e. by gninit_shutdown_emms(), this function will
 *	be called as necessary.
 *
 *	Parameters
 *		collection_id:		The identifier for the music collection associated with the
 *							metadata to be disabled. This is the value returned by
 *							gnplaylist_create_collection_id().
 */
gn_error_t
gnplaylist_close_collection_id(
	gn_collection_id_t	collection_id
	);


/*	gnplaylist_is_collection_id_open
 *
 *	Sets the is_open parameter to GN_TRUE if the collection is open.
 *	A collection is opened by a call to gnplaylist_open_collection_id().
 *
 *	Parameters
 *		collection_id:		The identifier of a collection associated with an MLDB
 *		is_open:			Set to GN_TRUE if the collection is open, otherwise GN_FALSE
 *
 *	Error Return
 *		PLMERR_InvalidArg	is_open is not a valid pointer
 *		PLMERR_NotInited	the playlist system has not been initialized
 *		GN_SUCCESS
 */
gn_error_t
gnplaylist_is_collection_id_open(
	gn_collection_id_t	 collection_id,
	gn_bool_t			*is_open
	);


/*	gnplaylist_enable_for_playlisting
 *
 *	Enable a registered collection for MLDB playlist generation. Playlist generation can operate
 *	against one or more collections. This function tells playlist to include the MLDB associated
 *	with this collection id in all subsequent playlist generation calls. If id has not been
 *	initialized by a call to gnplaylist_open_collection_id() the return value will be
 *	PLMERR_NotFound.
 *
 *	See the documentation for gnplaylist_create_collection_id and gnplaylist_open_collection_id
 *	for details on how a collection is created and opened.
 *
 *	An MLDB can be removed from playlist generation by a call to the
 *	gnplaylist_disable_for_playlisting function.
 *
 *	Parameters
 *		 collection_id:		The identifier of a collection associated with an MLDB.
 *							The id is the value returned by gnplaylist_create_collection_id.
 *
 *	Error Return
 *		PLMERR_InvalidArg	the id is not a valid collection ID
 *		PLMERR_NotInited	the playlist system has not been initialized
 *		PLMERR_NotFound		the collection for id is not currently opened
 *		GN_SUCCESS
 */
gn_error_t
gnplaylist_enable_for_playlisting(
	gn_collection_id_t	collection_id
	);


/*	gnplaylist_disable_for_playlisting
 *
 *	Disable a registered collection for MLDB playlist generation.  This function tells playlist
 *	to not consider the MLDB during subsequent playlist generation calls.
 *
 *	A collection can be included in playlist generation by a call to the
 *	gnplaylist_enable_for_playlisting function.
 *
 *	Parameters
 *		 id:	The identifier of a collection associated with an MLDB.
 *				The id is the value returned by gnplaylist_create_collection_id.
 *
 *	Error Return
 *		PLMERR_InvalidArg	id is not a valid collection ID
 *		PLMERR_NotInited	the playlist system has not been initialized
 *		PLMERR_NotFound		the collection for id is not currently opened
 *		GN_SUCCESS
 */
gn_error_t
gnplaylist_disable_for_playlisting(
	gn_collection_id_t	id
	);


/*	gnplaylist_is_enabled_for_playlisting
 *
 *	Sets the is_enabled parameter to GN_TRUE if the collection is enabled for playlisting.
 *	A collection is enabled for playlisting by a call to gnplaylist_enable_for_playlisting().
 *
 *	Parameters
 *		id:					The identifier of a collection associated with an MLDB
 *		is_enabled:			Set to GN_TRUE if the collection is open, otherwise GN_FALSE
 *
 *	Error Return
 *		PLMERR_InvalidArg	is_open is not a valid pointer
 *		PLMERR_NotInited	the playlist system has not been initialized
 *		GN_SUCCESS
 */
gn_error_t
gnplaylist_is_enabled_for_playlisting(
	gn_collection_id_t	id,
	gn_bool_t			*is_enabled
	);


/*	gnplaylist_get_collection_id_list
 *
 *	Provides an array of all of the registered collection IDs.
 *
 *	Parameters
 *		collection_ids:		On successful return, this object contains the list of registered
 *							collection IDs and the number of IDs in the list. The type
 *							gn_collection_id_list_t is declared in gn_playlist_types.h. If no
 *							collection IDs are registered the returned structure will have its
 *							count element = 0 and the id array element will not be allocated.
 *
 *  This function allocates memory for collection_ids. This memory must be
 *  freed by gnplaylist_free_collection_id_list().
 */
gn_error_t
gnplaylist_get_collection_id_list(
	gn_collection_id_list_t	**collection_ids
	);


/*	gnplaylist_get_opened_collection_id_list
 *
 *	Return a structure of collection ids that are currently open.  A collection is
 *	opened by a call to gnplaylist_open_collection_id().  Memory is allocated for
 *	the structure and the user is responsible for freeing it with a call to
 *	gnplaylist_free_collection_id_list.
 *
 *	If there are no opened collections then id_list will be allocated with
 *	id_list->count set to zero, id_list->ids set to GN_NULL, and the return status
 *	will be GN_SUCCESS.
 *
 *	Parameters
 *		id_list:	Address of a gn_collection_id_list_t* type that will be
 *					allocated and populated with the opened collection ids.
 *
 *	Error Return
 *		PLMERR_InvalidArg	id_list is not a valid pointer
 *		PLMERR_NotInited	the playlist system has not been initialized
 *		PLMERR_NoMemory		not able to allocate enough memory for the id_list
 *		GN_SUCCESS			id_list has been allocated
 */
gn_error_t
gnplaylist_get_opened_collection_id_list(
	gn_collection_id_list_t **id_list
	);


/*	gnplaylist_get_enabled_for_playlisting_list
 *
 *	Return a structure of collection ids that are currently enabled for playlist
 *	generation.  Memory is allocated for the structure and the user is responsible
 *	for freeing it with a call to gnplaylist_free_collection_id_list.
 *
 *	If no ids are currently enabled for playlisting then id_list will be allocated
 *	with id_list->idcount set to zero, id_list->ids set to GN_NULL, and the return status
 *	will be GN_SUCCESS.
 *
 *	Parameters
 *		id_list:	Address of a gn_collection_id_list_t* type that will be
 *					allocated and populated with collection ids currently enabled
 *					for playlist generation.
 *
 *	Error Return
 *		PLMERR_InvalidArg	id_list is not a valid pointer
 *		PLMERR_NotInited	the playlist system has not been initialized
 *		PLMERR_NoMemory		not able to allocate enough memory for the id_list
 *		GN_SUCCESS			id_list has been allocated and set with the enabled
 *							collection IDs.
 */
gn_error_t
gnplaylist_get_enabled_for_playlisting_list(
	gn_collection_id_list_t	**id_list
	);


/*	gnplaylist_free_collection_id_list
 *
 *	Free the storage associated with a gn_collection_id_list_t structure.
 *	On success, the id_list pointer is set to GN_NULL.
 *
 *	A collection ID list can be created by a call to any of these functions:
 *
 *		gnplaylist_get_collection_id_list
 *		gnplaylist_get_opened_collection_id_list
 *		gnplaylist_get_enabled_for_playlisting_list
 *
 *	Parameters
 *		id_list:	Address of an allocated gn_collection_id_list_t* type.
 *
 *	Error Return
 *		PLMERR_InvalidArg	id_list is not a valid pointer
 *		GN_SUCCESS
 */
gn_error_t
gnplaylist_free_collection_id_list(
	gn_collection_id_list_t	**id_list
	);


/*	------------------------------------------------------------------------------------------
 *	MARK:	Playlist Data Base (MLDB)
 *
 *	Each music collection has an associated Playlist data base, known as the metadata local
 *	data base (MLDB), for storing metadata related to the music files.
 *
 *
 *	MARK:	Populating the MLDB
 *
 *	The functions described in this section are used for managing the contents of a Playlist data
 *	base (MLDB).  These functions operate on an entry data structure referenced with an opaque
 *	pointer of type gnplaylist_entrydata_t, declared in header file gn_playlist_types.h
 */

/*	gnplaylist_newentry
 *
 *	Creates a new, empty entry data structure. This function is useful if you are manually creating
 *	track entries for an MLDB.  To free the entry data structure, call gnplaylist_freeentry()
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for this collection ID
 *
 *	Parameters:
 *		cid:			The collection id for the MLDB that will be associated with this
 *						entrydata.
 *
 *		filename:		Filename of the file. This value is required, and will be used as the
 *						primary key.
 *
 *		path:			Local filesystem path for the file (including trailing delimiter).
 *						This disambiguates entries which have the same filename.
 *						GN_NULL is a valid value.
 *
 *		p_ret_entrydata:	On success returns an allocated gnplaylist_entrydata_t handle.
 *						The handle is empty (except for filename/path).
 */
gn_error_t
gnplaylist_newentry(
	gn_collection_id_t		 cid,
	const gn_uchar_t		*filename,
	const gn_uchar_t		*path,
	gnplaylist_entrydata_t	*p_ret_entrydata
	);


/*	gnplaylist_addentry
 *
 *	Adds an entry for a song to the MLDB.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for this collection ID
 *
 *		PLMERR_Exists
 *						An entry with the same path/name is already in the database.
 *
 *		PLMDBERR_BADVERSION
 *						The entrydata structure is not the correct version for the collection_id.
 *						This would happen only if you are attempting to write an entrydata
 *						record created for an MLDB that is not the same version as the MLDB
 *						associated with the collection_id.
 *	Parameters:
 *		collection_id:	The ID of an open MLDB to which the song will be added.
 *
 *		filename:		Filename of the file. This value is required, and will be used
 *						as the primary key.
 *
 *		path:			Local filesystem path for the file (including trailing delimiter).
 *						This disambiguates entries which have the same filename.
 *						GN_NULL is a valid value.
 *
 *		entrydata:		Populated entrydata structure that describes the file. The entrydata
 *						parameter may have been populated from an online lookup, a local lookup,
 *						or manually, using the entrydata APIs.
 */
gn_error_t
gnplaylist_addentry(
	gn_collection_id_t		 collection_id,
	const gn_uchar_t		*filename,
	const gn_uchar_t		*path,
	gnplaylist_entrydata_t	 entrydata
	);


/*	gnplaylist_getentry
 *
 *	Finds the entry with the specified file pathname.  To free the entry data structure, call
 *	gnplaylist_freeentry().
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for this collection ID
 *
 *		DBERR_NotFound
 *						No entry was found with the filename/path combination.
 *
 *	Parameters:
 *		collection_id:	The ID of the MLDB from which the song will be obtained.
 *
 *		filename:		Filename of the file. This value is required, and will be used as
 *						the primary key.
 *
 *		path:			Local filesystem path for the file (including trailing delimiter).
 *						This disambiguates entries which have the same filename.
 *						GN_NULL is a valid value.
 *
 *		tagId:			An optional track unique ID to be used if filename is not specified.
 *						GN_NULL is a valid value.
 *
 *		p_ret_entrydata:	On success returns an allocated, populated gnplaylist_entrydata_t handle.
 */
gn_error_t
gnplaylist_getentry(
	gn_collection_id_t		 collection_id,
	const gn_uchar_t		*filename,
	const gn_uchar_t		*path,
	const gn_uchar_t		*tagId,
	gnplaylist_entrydata_t	*p_ret_entrydata
	);


/*	gnplaylist_get_entrydata_collection_id
 *
 *	Retrieves the collection identifier from an entry data structure.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_InvalidArg	Either the collection_id or entrydata pointers were null.
 *
 *	Parameters:
 *		entrydata:		Entrydata stucture.
 *		cid:			On return, the collection_id for the entrydata.
 */
gn_error_t
gnplaylist_get_entrydata_collection_id(
	gnplaylist_entrydata_t	 entrydata,
	gn_collection_id_t		*cid
	);


/*	gnplaylist_renameentry
 *
 *	Renames an entry for a song in the MLDB.  The old entry with the old path/filename will
 *	be replaced with a new entry with the same metadata but new path/filename.
 *
 *	Note that you can not rename the track if a track already exists with the new filename.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for this collection ID
 *
 *		PLMERR_Exists
 *						A track named newfilename already exists.
 *
 *		PLMDBERR_NOTFOUND
 *						No entry was found for the oldfilename.
 *
 *	Parameters:
 *		collection_id:	The ID of the MLDB from which the song will be renamed.
 *
 *		oldfilename:	Current filename.
 *
 *		oldpath:		Current local filesystem path for the file (including trailing delimiter).
 *
 *		newfilename:	New filename.
 *
 *		newpath:		New local filesystem path for the file (including trailing delimiter).
 *						GN_NULL is a valid value.
 */
gn_error_t
gnplaylist_renameentry(
	gn_collection_id_t		 collection_id,
	const gn_uchar_t		*oldfilename,
	const gn_uchar_t		*oldpath,
	const gn_uchar_t		*newfilename,
	const gn_uchar_t		*newpath
	);


/*	gnplaylist_deleteentry
 *
 *	Deletes an entry for a track from the MLDB.
 *
 *	Return Value: GN_SUCCESS or error code.:
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for this collection ID
 *
 *		DBERR_NotFound
 *						No entry was found with the filename/path combination.
 *
 *	Parameters:
 *		collection_id:	The ID of the MLDB from which the song will be deleted.
 *
 *		filename:		Filename of the file. This value is required, and will be used
 *						as the primary key.
 *
 *		path:			Local filesystem path for the file (including trailing delimiter).
 *						This disambiguates entries which have the same filename.
 *						GN_NULL is a valid value.
 */
gn_error_t
gnplaylist_deleteentry(
	gn_collection_id_t		 collection_id,
	const gn_uchar_t		*filename,
	const gn_uchar_t		*path
	);


/*	gnplaylist_freeentry
 *
 *	Frees an MLDB entrydata structure. gnplaylist_freeentry should be called for all entrydata
 *	structures obtained from a call to gnplaylist_getentry or gnplaylist_newentry.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		p_entrydata:	The entrydata that is to be freed.
 */
gn_error_t
gnplaylist_freeentry(
	gnplaylist_entrydata_t	*p_entrydata
	);


/*	MARK:	Setting MLDB Entry Data
 *
 *	gnplaylist_setentryfieldval
 *
 *	Sets the string value for a field in an entrydata structure.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for the collection ID associated with this entrydata.
 *
 *		PLMERR_PermissionError
 *						The value of this field may not be changed.
 *
 *	Parameters:
 *		entrydata:		Entrydata stucture.
 *
 *		field:			Identifier of the field to set. Field definitions
 *						for gnpl_crit_field_t can be found in gn_playlist_enums.h
 *
 *		newval:			String value for the field.
 *						Memory is allocated.
 */
gn_error_t
gnplaylist_setentryfieldval(
	gnplaylist_entrydata_t	 entrydata,
	gnpl_crit_field_t		 field,
	gn_uchar_t				*newval
	);


/*	gnplaylist_getentryfieldval
 *
 *	Retrieves the value, as a string, for a field in an entrydata structure.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for the collection ID associated with this entrydata.
 *
 *		PLMERR_PermissionError
 *						This field may not be read.
 *
 *		PLMERR_NotFound
 *						The field has not been set for this entrydata.
 *
 * Parameters:
 *		entrydata:		Entrydata stucture.
 *
 *		field:			Identifier of the field to set. Field definitions
 *						for gnpl_crit_field_t can be found in gn_playlist_enums.h
 *
 *		pbuf:			A pointer to a gn_uchar_t buffer that you allocate and provide;
 *
 *		size:			The size of your buffer (number of gn_uchar_t characters).
 */
gn_error_t
gnplaylist_getentryfieldval(
	gnplaylist_entrydata_t	 entrydata,
	gnpl_crit_field_t		 field,
	gn_uchar_t				*pbuf,
	gn_size_t				 size
	);


/*	gnplaylist_setentryfieldvalint
 *
 *	Sets the integer value for a field in an entrydata structure.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for the collection ID associated with this entrydata.
 *
 *		PLMERR_PermissionError
 *						The value of this field may not be changed.
 *
 *	Parameters:
 *		entrydata:		Entrydata stucture.
 *
 *		field:			Identifier of the field to set. Field definitions
 *						for gnpl_crit_field_t can be found in gn_playlist_enums.h
 *
 *		intval:			Integer value for the field.
 */
gn_error_t
gnplaylist_setentryfieldvalint(
	gnplaylist_entrydata_t	entrydata,
	gnpl_crit_field_t		field,
	gn_int32_t				intval
	);


/*	gnplaylist_getentryfieldvalint
 *
 *	Retrieves the value, as an integer, for a field in an entrydata structure.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for the collection ID associated with this entrydata.
 *
 *		PLMERR_PermissionError
 *						This field may not be read.
 *
 *		PLMERR_NotFound
 *						The field has not been set for this entrydata.
 *
 *	Parameters:
 *		entrydata:		Entrydata stucture.
 *
 *		field:			Identifier of the field to set. Field definitions
 *						for gnpl_crit_field_t can be found in gn_playlist_enums.h
 *
 *		pval:			On success returns the integer value of the field.
 */
gn_error_t
gnplaylist_getentryfieldvalint(
	gnplaylist_entrydata_t	 entrydata,
	gnpl_crit_field_t		 field,
	gn_int32_t				*pval
	);


/*	gnplaylist_setentryfieldvaldate
 *
 *	Sets the date value for a field in an entrydata structure.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for the collection ID associated with this entrydata.
 *
 *		PLMERR_PermissionError
 *						The value of this field may not be changed.
 *
 *	Parameters:
 *		entrydata:		Entrydata stucture.
 *
 *		field:			Identifier of the field to set. Field definitions
 *						for gnpl_crit_field_t can be found in gn_playlist_enums.h
 *
 *		newdate:		Date value for the field.
 */
gn_error_t
gnplaylist_setentryfieldvaldate(
	gnplaylist_entrydata_t	 entrydata,
	gnpl_crit_field_t		 field,
	gnpl_timestamp_t		*newdate
	);


/*	gnplaylist_getentryfieldvaldate
 *
 *	Retrieves the value, as a date (gnpl_timestamp_t), for a field in an entrydata structure.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for the collection ID associated with this entrydata.
 *
 *		PLMERR_PermissionError
 *						This field may not be read.
 *
 *		PLMERR_NotFound
 *						The field has not been set for this entrydata.
 *
 *	Parameters:
 *		entrydata:		Entrydata stucture.
 *
 *		field:			Identifier of the field to set. Field definitions
 *						for gnpl_crit_field_t can be found in gn_playlist_enums.h
 *
 *		pdate:			A pointer to a valid gnpl_timestamp_t struct.
 *						On success, populated with date value of the field.
 */
gn_error_t
gnplaylist_getentryfieldvaldate(
	gnplaylist_entrydata_t	 entrydata,
	gnpl_crit_field_t		 field,
	gnpl_timestamp_t		*pdate
	);


/*	gnplaylist_get_timestamp
 *
 *	Return a Playlist timestamp structure containing values for year, month,
 *	day, hour, and minute.
 *
 *	This function depends upon your implementation of the gn_get_time() function
 *	in the gn_time.c source file in the abstract layer for your platform.  If
 *	a time function is not supported on your platform then gnplaylist_get_timestamp()
 *	will set the timestamp year, month, day, hour, and minute values to 0.
 *
 *	Refer to the gn_time.h header for a description of gn_get_time() and the
 *	date format of gnpl_timestamp_t.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		GN_SUCCESS			This function will return GN_SUCCESS even if your system does not
 *							support a time function.
 *
 *		PLMERR_InvalidArg	The ts timestamp parameter is a null pointer.
 *
 *	Parameters:
 *		ts					A pointer to a gnpl_timestamp_t structure.
 */
gn_error_t
gnplaylist_get_timestamp(
	gnpl_timestamp_t	*ts
	);


/*	gnplaylist_setentrydevfieldval
 *
 *	Sets the string value for a developer field in an entrydata structure.
 *
 *	Return Value: GN_SUCCESS or error code.
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for the collection ID associated with this entrydata.
 *
 *	Parameters:
 *		entrydata:		Entrydata stucture.
 *
 *		dev_field_num:	Which developer field to set (> 0)
 *
 *		newval:			String value for the field.
 *						Memory is allocated.
 */
gn_error_t
gnplaylist_setentrydevfieldval(
	gnplaylist_entrydata_t	 entrydata,
	gn_uint16_t				 dev_field_num,
	const gn_uchar_t		*newval
	);


/*	gnplaylist_getentrydevfieldval
 *
 *	Retrieves the value, as a string, for a developer field in an entrydata structure.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for the collection ID associated with this entrydata.
 *
 *		PLMERR_PermissionError
 *						This field may not be read.
 *
 *		PLMERR_NotFound
 *						The field has not been set for this entrydata.
 *
 *	Parameters:
 *		entrydata:		Entrydata stucture.
 *
 *		dev_field_num:	Which developer field to get (> 0)
 *
 *		pbuf:			A pointer to a gn_uchar_t buffer that you allocate and provide;
 *
 *		size:			The size of your buffer (number of gn_uchar_t characters).
 */
gn_error_t
gnplaylist_getentrydevfieldval(
	gnplaylist_entrydata_t	 entrydata,
	gn_uint16_t				 dev_field_num,
	gn_uchar_t				*pbuf,
	gn_size_t				 size
	);


/*	gnplaylist_setentry_ext_data
 *
 *	Sets the extended data in an entrydata structure.
 *
 *	Return Value: GN_SUCCESS or error code:
 *
 *		PLMERR_InvalidArg	The entrydata record is null.
 *
 *		PLMERR_CollectionNotOpened
 *							The entrydata record was read from an MLDB but that MLDB is now
 *							closed.
 *
 *	Parameters:
 *		entrydata:			Entrydata stucture.
 *
 *		pext_data_album:	Structure containing album-level extended data to populate the entrydata
 *
 *		pext_data_track:	Structure containing track-level extended data to populate the entrydata
 */
gn_error_t
gnplaylist_setentry_ext_data(
	gnplaylist_entrydata_t	entrydata,
	gn_pext_data_t			pext_data_album,
	gn_pext_data_t			pext_data_track
	);


/*	gnplaylist_getentry_ext_data
 *
 *	Gets the extended data for an entrydata structure.
 *
 *	Memory is allocated for pext_data on success and the developer is expected
 *	to free it with a call to gn_ext_data_smart_free() when the data is no longer
 *	needed.
 *
 *	Return Value: GN_SUCCESS or error code:
 *
 *		PLMERR_InvalidArg	Either the entrydata record or pext_data are null.
 *
 *		PLMERR_CollectionNotOpened
 *							The entrydata record was read from an MLDB but that MLDB is now
 *							closed.
 *
 *		EDBERR_MemoryError	Not enough memory was available to allocate the pext_data structure.
 *
 *	Parameters:
 *		entrydata:			Entrydata stucture.
 *
 *		pext_data:			Address of an opaque pointer that will recieve the extended
 *							data.
 */
gn_error_t
gnplaylist_getentry_ext_data(
	gnplaylist_entrydata_t	 entrydata,
	gn_pext_data_t			*pext_data
	);


/*	MARK: DEPRECATED - gnplaylist_convert_album_to_entrydata
 *
 *	This api has been deprecated.
 *
 *	This function does not support entrydata updates for older MLDBs
 *	It is recomended that you use the new gnplaylist_album_data_to_entrydata api instead.
 *
 *	Converts a gn_palbum_track_t structure to an entrydata structure.  The returned
 *	p_ret_entrydata will contain all available information for the track specified by the
 *	album_data and trackindex including the filename and path that you provide.  Some entrydata
 *	fields are not obtained from the album data (gnpl_crit_field_file_created_date and
 *	gnpl_crit_field_file_modified_date for example) so you may wish to explicitlly set them
 *	yourself.
 *
 *	This function allocates memory for the returned p_ret_entrydata structure and it should
 *	be freed with a call to gnplaylist_freeentry.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		album_data:			Pointer to a gn_palbum_t structure.
 *		trackindex:			Which track on the disc to convert.
 *		filename:			The filename of the file as you would like it stored in the MLDB.
 *		path:				The path of the file as you would like it stored in the MLDB.
 *		p_ret_entrydata:	Returned pointer to an allocated gnplaylist_entrydata_t structure.
 */
gn_error_t
gnplaylist_convert_album_to_entrydata(
	gn_palbum_t				 album_data,
	gn_uint32_t				 trackindex,
	const gn_uchar_t		*filename,
	const gn_uchar_t		*path,
	gnplaylist_entrydata_t	*p_ret_entrydata
	);


/*	gnplaylist_album_data_to_entrydata
 *
 *	This function replaces the older gnplaylist_convert_album_to_entrydata which has been deprecated.
 *
 *	Constructs a new Playlist entry_data structure from an album_data structure containing all
 *	available information for the track specified by album_data and trackindex  including the
 *	filename and path that you provide.  Some entrydata fields are not obtained from the album
 *	data (gnpl_crit_field_file_created_date and gnpl_crit_field_file_modified_date for example)
 *	so you may wish to explicitlly set them yourself.
 *
 *	This function allocates memory for the returned p_ret_entrydata structure and it should
 *	be freed with a call to gnplaylist_freeentry.
 *
 *	Parameters:
 *		collection_id:
 *			The ID of the MLDB for which the entrydata is intended.  Necessary for backward
 *			compatibility version support when updating older MLDBs.  If the collection_id is
 *			not known then use GN_INVALID_COLLECTION_ID for current MLDB version support.
 *
 *		album_data:
 *			Pointer to a gn_palbum_t structure.
 *
 *		trackindex:
 *			The album track on the disc to convert.
 *
 *		filename:
 *			The filename of the file as you would like it stored in the MLDB.
 *
 *		path:
 *			The path of the file as you would like it stored in the MLDB.
 *
 *		p_ret_entrydata:
 *			Returned pointer to an allocated gnplaylist_entrydata_t structure.
 *
 *	Error Return:
 *		GN_SUCCESS
 *			The album_data was successfuly converted to an entrydata structure.
 *
 *		PLMERR_UnsupportedFunctionality
 *			Playlist is not supported or is not initialized.
 *
 *		PLMERR_InvalidArg
 *			Either album_data or the entrydata pointers were null.
 *
 *		PLMERR_CollectionNotOpened
 *			No open MLDB was found for the collection ID.
 *
 *		PLMERR_NoMemory
 *			Not enough memory was available to allocate the entrydata structure.
 */
gn_error_t
gnplaylist_album_data_to_entrydata(
	gn_collection_id_t		 collection_id,
	gn_palbum_t				 album_data,
	gn_uint32_t				 trackindex,
	const gn_uchar_t		*filename,
	const gn_uchar_t		*path,
	gnplaylist_entrydata_t	*p_ret_entrydata
	);


/*	gnplaylist_get_genre_array
 *
 *	Get the genre array associated with the playlist entry data..
 *	Call this function when populating your ASR/TTS dictionaries and grammars.
 *
 *	Parameters
 *		entrydata:		The playlist entry data containing the genre.
 *		genre_array:	A pointer to the genre array. This memory for this
 *						array is owned by the caller. Call the function
 *						gn_genre_array_smart_free to free the allocated array.
 *
 *	Error Return
 *		GN_SUCCESS				The genre array was successfully retrieved.
 *		PLMERR_InvalidArg		At least one of the parameters is a NULL
 *								pointer.
 *		GNLISTSERR_NotInited	The list subsystem has not been initialized.
 *		GNLISTSERR_NoMemory		Memory allocation error.
 *		GNLISTSERR_NotFound		Display information does not exist for the
 *								genre master ID.
 *
 *	Remarks:
 *		The function will allocate memory internally the for gn_pgenre_arr_t.
 *		The caller must free genre_array by calling gn_genre_array_smart_free.
 *		If the error return value is GN_SUCCESS, then the *genre_array value
 *		will not be GN_NULL.
 *		If the error return value is not GN_SUCCESS, then the *genre_array
 *		value is indeterminate.
 */
gn_error_t
gnplaylist_get_genre_array(
	gnplaylist_entrydata_t entrydata,
	gn_pgenre_arr_t* genre_array
	);


/*	MARK:	Modifying MLDB Entry Data
 *
 *	gnplaylist_updateentry
 *
 *	Update an existing entry in the MLDB. If the specified filename/path does not exist in
 *	the MLDB a DBERR_NotFound status is returned.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for the collection ID associated with this entrydata.
 *
 *		DBERR_NotFound
 *						No entry was found with the filename/path combination.
 *
 *	Parameters:
 *		filename:		Filename of the file. This value is required,
 *						and will be used as the primary key.
 *
 *		path:			Local filesystem path for the file (including trailing delimiter).
 *						This disambiguates entries which have the same filename.
 *						GN_NULL is a valid value.
 *
 *		entrydata:		Populated entrydata structure that describes the file.
 *						The entrydata parameter may have been populated from an
 *						online lookup, a local lookup, or manually, using the
 *						entrydata APIs.
 */
gn_error_t
gnplaylist_updateentry(
	const gn_uchar_t		*filename,
	const gn_uchar_t		*path,
	gnplaylist_entrydata_t	 entrydata
	);

/*	------------------------------------------------------------------------------------------
 *	The next two functions should be built only if textid is included in the configuration.
 */
#if defined(GN_TEXTID)

/*	gnplaylist_set_entry_equal_to_contributor
 *
 *	Set the artist name, genre ID, origin, era, artist type, in an MLDB entry
 *	to be the same as the specified contributor.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_InvalidArg
 *						Either the contributor_data or entrydata is null.
 *
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for the collection ID associated with this entrydata.
 *
 *		GNTEXTIDERR_InvalidContributorInfo
 *						The contributor_data does not contain valid contributor information.
 *
 *	Parameters:
 *		contributor_data:
 *						Contributor data obtained by one of the gn_textid_get_contributor
 *						functions.
 *
 *		entrydata:		Entrydata stucture.
 */
gn_error_t
gnplaylist_set_entry_equal_to_contributor(
	gn_textid_presult_data_t	contributor_data,
	gnplaylist_entrydata_t		entrydata
	);


/*	gnplaylist_set_entry_genre_like_contributor
 *
 *	Set the genre ID in an MLDB entry to be the same genre as the specified contributor.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_InvalidArg
 *						Either the contributor_data or entrydata is null.
 *
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for the collection ID associated with this entrydata.
 *
 *		GNTEXTIDERR_InvalidContributorInfo
 *						The contributor_data does not contain valid contributor information.
 *
 *	Parameters:
 *		contributor_data:
 *						Contributor data obtained by one of the gn_textid_get_contributor
 *						functions.
 *
 *		entrydata:		Entrydata stucture.
 */
gn_error_t
gnplaylist_set_entry_genre_like_contributor(
	gn_textid_presult_data_t	contributor_data,
	gnplaylist_entrydata_t		entrydata
	);

#endif	/* GN_TEXTID */
/*	------------------------------------------------------------------------------------------	*/

/*	gnplaylist_updateplaystat
 *
 *	For the filename/path specified, update the playcount by the specified delta, and the last
 *	played date with the provided timestamp.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for this collection ID
 *
 *		DBERR_NotFound
 *						No entry was found with the filename/path combination
 *
 *	Parameters:
 *		collection_id:	The ID of the MLDB containing the last played date to set.
 *
 *		filename:		Filename of the file. This value is required,
 *						and will be used as the primary key.
 *
 *		path:			Local filesystem path for the file (including trailing delimiter).
 *						GN_NULL is a valid value.
 *
 *		lastplaytime:	A timestamp to which the last played date of the song entry will be set.
 *
 *		delta:			How much to increment the playcount.  Usually 1.
 */
gn_error_t
gnplaylist_updateplaystat(
	gn_collection_id_t		 collection_id,
	const gn_uchar_t		*filename,
	const gn_uchar_t		*path,
	gnpl_timestamp_t		*lastplaytime,
	gn_int32_t				 delta
	);


/*	gnplaylist_updaterating
 *
 *	For the filename/path specified, update the user's rating to the specified value
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for this collection ID
 *
 *		DBERR_NotFound
 *						No entry was found with the filename/path combination
 *
 *	Parameters:
 *		collection_id:	The ID of the MLDB containing the rating to set.
 *
 *		filename:		Filename of the file. This value is required,
 *						and will be used as the primary key.
 *
 *		path:			Local filesystem path for the file (including trailing delimiter).
 *						GN_NULL is a valid value.
 *
 *		rating:			The new rating value.  0-100.
 */
gn_error_t
gnplaylist_updaterating(
	gn_collection_id_t		 collection_id,
	const gn_uchar_t		*filename,
	const gn_uchar_t		*path,
	gn_int32_t				 rating
	);


/*	gnplaylist_commitdb
 *
 *	Commits any changes made to the MLDB to disk.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for this collection ID
 *
 *	Parameters:
 *		collection_id:	The ID of the MLDB to commit.
 */
gn_error_t
gnplaylist_commitdb(
	gn_collection_id_t	collection_id
	);


/*	MARK:	Browsing the MLDB
 *
 *	Use the functions described in this section to browse a Playlist data base (MLDB) for entries
 *	matching a specified set of constraints.
 *
 *	To browse the MLDB you must first call gnplaylist_findopen to open an iterator to the
 *	database. You can then iterate over all of the entries using gnplaylist_findnext.
 *	When you are finished browsing you close the MLDB with a call to gnplaylist_findclose.
 *
 *	The gnplaylist_findopen function requires a gnplaylist_findinfo_t structure that allows you
 *	to specify certain fields to limit the results you get back from the findopen call.
 *	You can populate a findinfo structure with one of the gnplaylist_findinfo_set calls to set
 *	up a filter for the results that the iterator will provide.
 *
 *	For more sophisticated functionality when getting results from the database, do not use
 *	the browse functionality. Instead, you can create a playlist generator, and use
 *	gnplaylist_generateplaylist_results.
 */

/*	gnplaylist_newfindinfo
 *
 *	Allocates a new gnplaylist_findinfo_t structure.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		p_findinfo:		On success allocates a gnplaylist_findinfo_t structure.
 *						Must be freed with a call to gnplaylist_freefindinfo()
 */
gn_error_t
gnplaylist_newfindinfo(
	gnplaylist_findinfo_t	*p_findinfo
	);


/*	gnplaylist_findinfo_set_track_filename
 *
 *	Sets the track file name for a findinfo structure.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:		A valid findinfo structure.
 *		file_name:		The track file name to filter by.  Only exact matches are supported.
 */
gn_error_t
gnplaylist_findinfo_set_track_filename(
	gnplaylist_findinfo_t	findinfo,
	const gn_uchar_t		*file_name
	);


/*	gnplaylist_findinfo_set_track_id
 *
 *	Sets the track id for a findinfo structure.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:		A valid findinfo structure.
 *		track_id:		The track id to filter by.  Only exact matches are supported.
 */
gn_error_t
gnplaylist_findinfo_set_track_id(
	gnplaylist_findinfo_t	findinfo,
	gn_uint32_t				track_id
	);


/*	gnplaylist_findinfo_set_primary_mood_id
 *
 *	Sets the primary_mood_id for a findinfo structure.
 *	The primary_mood_id specified here is a public display id.  It is mapped internally to a
 *	master mood id.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:			A valid findinfo
 *		primary_mood_id:	The primary mood ID (from the mood list)
 */
gn_error_t
gnplaylist_findinfo_set_primary_mood_id(
	gnplaylist_findinfo_t	findinfo,
	gn_uint32_t				primary_mood_id
	);


/*	gnplaylist_findinfo_set_primary_tempo_id
 *
 *	Sets the primary_tempo_id for a findinfo structure.
 *	The primary_tempo_id specified here is a public display id.  It is mapped internally to a
 *	master tempo id.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:			A valid findinfo
 *		primary_tempo_id:	The primary tempo ID (from the tempo list)
 */
gn_error_t
gnplaylist_findinfo_set_primary_tempo_id(
	gnplaylist_findinfo_t	findinfo,
	gn_uint32_t				primary_tempo_id
	);


/*	gnplaylist_findinfo_setalbum
 *
 *	Sets the album value for a findinfo structure.
 *
 *	DEPRECATED:		This function is valid only for MLDB versions 5.3 and older.
 *	The album name is no longer an indexed field.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:		A valid findinfo structure.
 *		album:			The album name to filter by.  Only exact matches are supported.
 */
gn_error_t
gnplaylist_findinfo_setalbum(
	gnplaylist_findinfo_t	findinfo,
	const gn_uchar_t		*album
	);


/*	gnplaylist_findinfo_setartist
 *
 *	Sets the artist name value for a findinfo structure.
 *
 *	DEPRECATED:		This function is valid only for MLDB versions 5.3 and older.
 *	The artist name is no longer an indexed field.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:		A valid findinfo structure.
 *		artist:			The artist name to filter by.  Only exact matches are supported.
 */
gn_error_t
gnplaylist_findinfo_setartist(
	gnplaylist_findinfo_t	findinfo,
	const gn_uchar_t		*artist
	);


/*	gnplaylist_findinfo_setartist_type
 *
 *	Sets the artist type for a findinfo structure.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:		A valid findinfo
 *		artisttype_id:	The ID of the artist type (from the artist-type list)
 */
gn_error_t
gnplaylist_findinfo_setartist_type(
	gnplaylist_findinfo_t	findinfo,
	gn_uint32_t				artisttype_id
	);


/*	gnplaylist_findinfo_setyear
 *
 *	Sets the minimum and maximum (release) year range for a findinfo structure.
 *	If the release year of a track falls within the low and high range then it is
 *	considered in range of the find criteria.  Special cases exist for when either
 *	year_low or year_high are set to 0:
 *
 *	if year_low == 0 then the key_year is in range if it is less than or equal to year_high
 *	if year_high == 0 then the key_year is in range if it is greater than or equal to year_low
 *	if year_low and year_high are both 0 then all key_years are considered to be in range.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:		A valid findinfo
 *		year_low:		The beginning year of the range sought
 *		year_high:		The end year for the range
 */
gn_error_t
gnplaylist_findinfo_setyear(
	gnplaylist_findinfo_t	findinfo,
	gn_uint32_t				year_low,
	gn_uint32_t				year_high
	);


/*	gnplaylist_findinfo_setera
 *
 *	Sets the era id for a findinfo structure.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:		A valid findinfo
 *		era_id:			The ID of the era (from the era list)
 */
gn_error_t
gnplaylist_findinfo_setera(
	gnplaylist_findinfo_t	findinfo,
	gn_uint32_t				era_id
	);

/*	gnplaylist_findinfo_setregion
 *
 *	Sets the region (origin) id for a findinfo structure.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:		A valid findinfo
 *		region_id:		The ID of the region (from the artist origins list)
 */
gn_error_t
gnplaylist_findinfo_setregion(
	gnplaylist_findinfo_t	findinfo,
	gn_uint32_t				region_id
	);


/*	gnplaylist_findinfo_setgenre
 *
 *	Sets the genre id for a findinfo structure.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:		A valid findinfo
 *		genre_id:		The ID of the genre (from the genre list)
 */
gn_error_t
gnplaylist_findinfo_setgenre(
	gnplaylist_findinfo_t	findinfo,
	gn_uint32_t				genre_id
	);


/*	gnplaylist_findinfo_setdateaddedrange
 *
 *	Sets the minimum and maximum added date for a findinfo structure.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:			A valid findinfo structure.
 *		added_low:			The beginning time of the range sought.
 *							Can be GN_NULL to specify all dates before added_high.
 *		added_high:			The end date of the range.  If day, month, and year
 *							are equal to added_low, all results for that
 *							date only will be returned.
 *							Can be GN_NULL to specify all dates after added_low.
 */
gn_error_t
gnplaylist_findinfo_setdateaddedrange(
	gnplaylist_findinfo_t	 findinfo,
	gnpl_timestamp_t		*added_low,
	gnpl_timestamp_t		*added_high
	);


/*	gnplaylist_findinfo_setlastplayrange
 *
 *	Sets the minimum and maximum lastplay date for a findinfo structure.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:			A valid findinfo structure.
 *		lastplay_low:		The beginning time of the range sought.
 *							Can be GN_NULL to specify all dates before lastplay_high.
 *		lastplay_high:		The end date of the range.  If day, month, and year
 *							are equal to lastplay_low, all results for that
 *							date only will be returned.
 *							Can be GN_NULL to specify all dates after lastplay_low.
 */
gn_error_t
gnplaylist_findinfo_setlastplayrange(
	gnplaylist_findinfo_t	 findinfo,
	gnpl_timestamp_t		*lastplay_low,
	gnpl_timestamp_t		*lastplay_high
	);


/*	gnplaylist_findinfo_setplays
 *
 *	Sets the minimum and maximum playcount for a findinfo structure.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:			A valid findinfo structure.
 *		plays_low:			The lowest playcount sought.
 *		plays_high:			The highest playcount sought.
 */
gn_error_t
gnplaylist_findinfo_setplays(
	gnplaylist_findinfo_t	findinfo,
	gn_uint32_t				plays_low,
	gn_uint32_t				plays_high
	);


/*	gnplaylist_findinfo_setrating
 *
 *	Sets the minimum and maximum user rating for a findinfo structure.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:			A valid findinfo structure.
 *		rating_low:			The lowest rating sought.
 *		rating_high:		The highest rating sought.
 */
gn_error_t
gnplaylist_findinfo_setrating(
	gnplaylist_findinfo_t	findinfo,
	gn_uint32_t				rating_low,
	gn_uint32_t				rating_high
	);


/*	gnplaylist_findinfo_setnum_dev1
 *
 *	Sets the minimum and maximum values for num_dev1 in a findinfo structure.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:			A valid findinfo structure.
 *		low:				The lowest sought.
 *		high:				The highest sought.
 */
gn_error_t
gnplaylist_findinfo_setnum_dev1(
	gnplaylist_findinfo_t	findinfo,
	gn_uint32_t				num_dev1_low,
	gn_uint32_t				num_dev1_high
	);


/*	gnplaylist_findinfo_setnum_dev2
 *
 *	Sets the minimum and maximum values for num_dev2 in a findinfo structure.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:			A valid findinfo structure.
 *		low:				The lowest sought.
 *		high:				The highest sought.
 */
gn_error_t
gnplaylist_findinfo_setnum_dev2(
	gnplaylist_findinfo_t	findinfo,
	gn_uint32_t				num_dev2_low,
	gn_uint32_t				num_dev2_high
	);


/*	gnplaylist_findinfo_setnum_dev3
 *
 *	Sets the minimum and maximum values for num_dev3 in a findinfo structure.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:			A valid findinfo structure.
 *		low:				The lowest sought.
 *		high:				The highest sought.
 */
gn_error_t
gnplaylist_findinfo_setnum_dev3(
	gnplaylist_findinfo_t	findinfo,
	gn_uint32_t				num_dev3_low,
	gn_uint32_t				num_dev3_high
	);


/*	gnplaylist_findinfo_setalph_dev1
 *
 *	Sets the alph_dev1 value for a findinfo structure.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:		A valid findinfo structure.
 *		alph_dev1:		The alph_dev1 string to filter by.  Only exact matches are supported.
 */
gn_error_t
gnplaylist_findinfo_setalph_dev1(
	gnplaylist_findinfo_t	findinfo,
	gn_uchar_t				*alph_dev1
	);


/*	gnplaylist_findinfo_setalph_dev2
 *
 *	Sets the alph_dev2 value for a findinfo structure.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:		A valid findinfo structure.
 *		alph_dev2:		The alph_dev2 string to filter by.  Only exact matches are supported.
 */
gn_error_t
gnplaylist_findinfo_setalph_dev2(
	gnplaylist_findinfo_t	findinfo,
	gn_uchar_t				*alph_dev2
	);


/*	gnplaylist_findinfo_setalph_dev3
 *
 *	Sets the alph_dev3 value for a findinfo structure.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		findinfo:		A valid findinfo structure.
 *		alph_dev3:		The alph_dev3 string to filter by.  Only exact matches are supported.
 */
gn_error_t
gnplaylist_findinfo_setalph_dev3(
	gnplaylist_findinfo_t	findinfo,
	gn_uchar_t				*alph_dev3
	);


/*	gnplaylist_freefindinfo
 *
 *	Frees a gnplaylist_findinfo_t structure.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		p_findinfo:		The valid findinfo to be freed.
 */
gn_error_t
gnplaylist_freefindinfo(
	gnplaylist_findinfo_t	*p_findinfo
	);


/*	gnplaylist_findopen
 *
 *	Opens the playlist database for enumeration. Returns an iterator that lets you iterate
 *	over the results. If the MLDB contains no track entries the returned error status will
 *	be GN_SUCCESS and iter_handle will be set to GN_NULL.
 *
 *	The returned iter_handle must be closed with a gnplaylist_findclose call.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_CollectionNotOpened
 *						No open MLDB was found for this collection ID.
 *
 *		PLMERR_NoMemory
 *						Not enough memory to allocate the iter_handle.
 *
 *	Parameters:
 *		collection_id:	The ID of the MLDB to search.
 *
 *		findinfo:		The optional findinfo defines a filter for the results.
 *						Use GN_NULL if you wish to browse every track entry in the MLDB.
 *
 *		iter_handle:	On success returns an iterator that is used to enumerate the
 *						results in gnplaylist_findnext calls.  Is set to GN_NULL if
 *						no entries were found that match the findinfo.
 */
gn_error_t
gnplaylist_findopen(
	gn_collection_id_t				 collection_id,
	gnplaylist_findinfo_t			 findinfo,
	gnplaylist_iterator_handle_t	*iter_handle
	);


/*	gnplaylist_findnext
 *
 *	Iterates to the next song in the MLDB for the given iter_handle.
 *	Returns GNERR_NotFound after the last item has been reached.
 *	On success, the caller should free p_entrydata using gnplaylist_freeentry().
 *
 *	Return Value: GN_SUCCESS or error code.
 *	Returns GNERR_NotFound if no more entries are available.
 *
 *	Parameters:
 *		iter_handle:		A valid gnplaylist_iterator_handle_t, returned from a call to
 *							gnplaylist_findopen.
 *		p_entrydata:		On success returns an entrydata pointer with full information about
 *							the found entry. Should be freed with gnplaylist_freeentry.
 */
gn_error_t
gnplaylist_findnext(
	gnplaylist_iterator_handle_t	 iter_handle,
	gnplaylist_entrydata_t			*p_entrydata
	);


/*	gnplaylist_findclose
 *
 *	Closes and frees all memory for a gnplaylist_iterator_handle_t that was opened by
 *	gnplaylist_findopen.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		iter_handle:	an opened gnplaylist_iterator_handle_t
 */
gn_error_t
gnplaylist_findclose(
	gnplaylist_iterator_handle_t	iter_handle
	);


/*	MARK:	MLDB Management
 *
 *
 *	gnplaylist_backup_mldb
 *
 *	Makes a backup of the MLDB associated with a given collection.
 *
 *	Parameters
 *		collection_id:		The identifier for the music collection associated with the
 *							MLDB to be backed up. This is the value returned by
 *							gnplaylist_create_collection_id().
 */
gn_error_t
gnplaylist_backup_mldb(
	gn_collection_id_t	collection_id
	);


/*	gnplaylist_revert_mldb
 *
 *	Replaces the MLDB associated with a given collection with its backup. If a
 *	backup is not present, EDBIMERR_RevertMissingBackup error will be returned.
 *	In this case, if the database is corrupt, it will likely be necessary to
 *	unregister the collection gnplaylist_delete_collection_id().
 *
 *	Parameters
 *		collection_id:		The identifier for the music collection associated with the
 *							MLDB to be reverted. This is the value returned by
 *							gnplaylist_create_collection_id().
 */
gn_error_t
gnplaylist_revert_mldb(
	gn_collection_id_t	collection_id
	);


/*	gnplaylist_get_mldb_physical_size
 *
 *	Return the physical file size in bytes of the MLDB.
 *
 *	The current MLDB impelementation consists of one file: mldb<id>.pdb.  Previous MLDB implementations
 *	consisted of two files: mldb<id>.pdb and mldb<id>.idx.  The "mldb physical size" is the sum of
 *	all the physical MLDB file sizes.
 */
gn_error_t
gnplaylist_get_mldb_physical_size(
	gn_collection_id_t	 id,
	gn_uint32_t			*physical_size
	);


/*	gnplaylist_get_mldb_compacted_size
 *
 *	Return a close approximation of the physical file size if the MLDB were to be compacted.
 *
 *	The compacted size is the physical size (see gnplaylist_get_mldb_physical_size) minus the sum
 *	of all the available free space in the MLDB.
 */
gn_error_t
gnplaylist_get_mldb_compacted_size(
	gn_collection_id_t	 id,
	gn_uint32_t			*compacted_size
	);


/*	gnplaylist_compact_mldb
 *
 *	Compacts the MLDB associated with a given collection.
 *
 *	Deleting an item from an MLDB with gnplaylist_delete_entry() only logically
 *	deletes that item. It does not shrink the MLDB file, though it does make the
 *	space in the file available for future additions. After many deletions the
 *	MLDB can become fragmented. Compaction defragments the MLDB, shrinking its
 *	size and increasing its efficiency.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		DBERR_IncompatibleDBs
 *		PLMERR_UnsupportedFunctionality
 *							Either one of these error codes means that the MLDB is not
 *							the latest version.  MLDB compaction is only supported on the
 *							current MLDB version.  The MLDB should be converted to the latest
 *							version by using the gnplaylist_convert_mldb API.  Converting the MLDB
 *                          will also reclaim the deleted space.
 *
 *	Parameters
 *		collection_id:		The identifier for the music collection associated with the
 *							MLDB to be compacted. This is the value returned by
 *							gnplaylist_create_collection_id().
 */
gn_error_t
gnplaylist_compact_mldb(
	gn_collection_id_t	collection_id
	);


/*	gnplaylist_export_mldb
 *
 *	Exports an MLDB to an external transport medium (such as a removable memory stick).
 *	When used in conjunction with gnplaylist_import_mldb, this allows MLDBs to be transported
 *	between devices, such as a hand-held device and an Internet-connected per-sonal computer.
 *
 *	The output_path parameter gives the full path to the destination directory on the external
 *	medium, terminated with the appropriate platform-specific directory separator character.
 *	The MLDB identified by collection identifier collection_id on the exporting device is
 *	copied to the designated directory
 *
 *	Return Value: GN_SUCCESS or error code:
 *		EDBIMERR_MLDBFilesExist
 *						Indicates the destination directory (output_path) already contains
 *						an MLDB with collection identifier collection_id.
 *
 *	Parameters
 *		output_path:	The path to the folder on the transport media as seen on
 *                      the source device, including the final directory
 *                      directory delimiter, e.g. '\'.
 *		collection_id:	The ID of the MLDB to be exported.
 */
gn_error_t
gnplaylist_export_mldb(
	const gn_uchar_t			*output_path,
	const gn_collection_id_t	 collection_id
	);


/*	gnplaylist_import_mldb
 *
 *	Imports an MLDB from an external transport medium (such as a removable memory stick).
 *	When used in conjunction with gnplaylist_export_mldb, this allows MLDBs to be transported
 *	between devices, such as a hand-held device and an Internet-connected per-sonal computer.
 *
 *	The input_path parameter gives the full path to the source directory on the external medium
 *	contain-ing the MLDB to be imported, terminated with the appropriate platform-specific
 *	directory separator character. The MLDB identified by collection identifier collection_id on
 *	the source device is copied to the MLDB directory on the importing device.  The MLDB is
 *	registered on the importing device and assigned a unique collection identifier on that device.
 *	This new collection identifier is returned via the output parameter new_collection_id.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *     input_path:        The full path to the folder of the transport media as
 *                        seen on the target device, including the final
 *                        directory delimiter, e.g. '\'.
 *     collection_id:     The ID of the MLDB on the source device
 *     new_collection_id: The collection ID assigned to the MLDB on the target
 *                        device
 */
gn_error_t
gnplaylist_import_mldb(
	const gn_uchar_t			*input_path,
	const gn_collection_id_t	 collection_id,
	gn_collection_id_t			*new_collection_id
	);


/*	gnplaylist_convert_mldb
 *
 *	Converts the Playlist data base associated with a given collection identifier to the current
 *	format.
 *
 *	If the Playlist data base associated with old_cid does not conform to the currently defined
 *	format, a new collection is created, with a Playlist data base in the current format converted
 *	from the old collec-tion's data, and returned via new_cid.  The old collection's Playlist data
 *	base is not modified.
 *
 *	If the old collection's Playlist data base is already in the current format, new_cid is set
 *	to the constant GN_INVALID_COLLECTION_ID and the function returns GN_SUCCESS.
 *
 *	If the existing collection was already open, it remains open; the new collection is not opened.
 *
 *	Note:  Since the Playlist subsystem is backward-compatible with older data base formats, it
 *	is not necessary to convert existing databases with this function.  However, the current format
 *	is more efficient than earlier versions and a conversion will produce improvements in performance.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		old_cid:		An existing collection ID.
 *		new_cid:		A pointer to a gn_collection_id_t to recieve the new collection ID.
 */
gn_error_t
gnplaylist_convert_mldb(
	gn_collection_id_t		old_cid,
	gn_collection_id_t		*new_cid
	);


/*	gnplaylist_check_mldb
 *
 *	Perform a database integrity check on the MLDB.  Depending on the number of tracks in the
 *	collection, this operation may take some time.
 *
 *	This function is intended for use during the development phase of a product.  While this
 *	function helps determine if the MLDB is corrupt, there is no function to repair the MLDB.
 *	See gnplaylist_revert_mldb for how to recover a music collection with its backup.
 *
 *	The MLDB needs to be closed during the integrity check.  If the MLDB is currently open, it
 *	will be re-opened (and re-enabled for Playlisting if appropriate) if the check is successful.
 *
 *	Return Value: GN_SUCCESS or error code.  Receiving an error value indicates an irreparable
 *	file corruption in the MLDB.
 */
gn_error_t
gnplaylist_check_mldb(
	gn_collection_id_t		collection_id
	);


/*	------------------------------------------------------------------------------------------
 *	MARK:	Playlist Generators
 *
 *	Dynamic playlist generators allow your application to select tracks from the user's music
 *	library based on specified generation criteria.  You can save and store the generators, your
 *	application can preload them, and users can create their own.  
 */

/*	MARK:	Creating and Destroying Generators
 *
 *	gnplaylist_plgen_create_playlistgen
 *
 *	Creates a new, empty playlist generator. You can use this generator for "on the fly"
 *	playlist generation on its own or you can add it to a generator list with a call to
 *	gnplaylist_addgenerator. The caller must either free the new generator using
 *	gnplaylist_plgen_freeplaylistgen, or add it to a generator list that is managed by
 *	the Playlist Manager.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		p_ret_hpl:		On success, an allocated playlist generator;
 *						on error, will be set to GN_NULL.
 */
gn_error_t
gnplaylist_plgen_create_playlistgen(
	gnpl_playlist_gen_handle_t		*p_ret_hpl
	);


/*	gnplaylist_plgen_cloneplaylistgen
 *
 *	Clones (copies) the playlist generator referred to by hpl and returns a pointer in
 *	p_ret_hpl to the newly allocated copy of the generator. Cloning includes copying all
 *	of the criteria, limits, and ranking data. The caller must either free the copy using
 *	gnplaylist_plgen_freeplaylistgen, or add it to a generator list that is managed by the
 *	Playlist Manager.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		hpl:			A valid playlist generator.
 *		p_ret_hpl:		On success, an allocated playlist generator with copies of all of
 *						the attributes/fields/limits/criteria of the original; on error,
 *						will be set to GN_NULL.
 */
gn_error_t
gnplaylist_plgen_cloneplaylistgen(
	gnpl_playlist_gen_handle_t	 hpl,
	gnpl_playlist_gen_handle_t	*p_ret_hpl
	);


/*	gnplaylist_plgen_freeplaylistgen
 *
 *	Frees a playlist generator. Not necessary if the playlist generator is part of a list
 *	that is managed by the Playlist Manager
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		hpl:			A playlist generator
 */
gn_error_t
gnplaylist_plgen_freeplaylistgen(
	gnpl_playlist_gen_handle_t	*hpl
	);


/*	MARK:	Generator Attribute Access
 *
 *	gnplaylist_plgen_setname
 *
 *	Sets a name for the playlist generator. Memory is allocated by this function in order to
 *	duplicate the string pointed to by name. It is not required to name your playlist
 *	generators but it is recommended if your application will need to display the playlist
 *	generators.
 *
 *	Return Value: GN_SUCCESS, or error code including PLMERR_NoMemory.
 *
 *	Parameters
 *		hpl:			A playlist generator.
 *		name:			The name of the playlist generator.
 */
gn_error_t
gnplaylist_plgen_setname(
	gnpl_playlist_gen_handle_t	 hpl,
	const gn_uchar_t			*name
	);


/*	gnplaylist_plgen_getname
 *
 *	Retrieves the name for the playlist generator.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:			A playlist generator.
 *		p_name:			On success, a pointer to the name of the playlist generator.
 *						The returned string pointer is owned by the generator, do not free it.
 */
gn_error_t
gnplaylist_plgen_getname(
	gnpl_playlist_gen_handle_t	hpl,
	const gn_uchar_t			**p_name
	);


/*	gnplaylist_plgen_setdescription
 *
 *	Sets a description for the playlist generator. Memory is allocated by this function in
 *	order to duplicate the string pointed to by desc. It is not required to set a description
 *	for your playlist generators but it is recommended if your application will need to display
 *	the playlist generators.
 *
 *	Return Value: GN_SUCCESS, or error code including PLMERR_NoMemory.
 *
 *	Parameters
 *		hpl:			A playlist generator.
 *		desc:			The description of the playlist generator.
 */
gn_error_t
gnplaylist_plgen_setdescription(
	gnpl_playlist_gen_handle_t	 hpl,
	const gn_uchar_t			*desc
	);


/*	gnplaylist_plgen_getdescription
 *
 *	Retrieves the description for the playlist generator.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:			A playlist generator.
 *		p_desc:			On success, a pointer to the description of the playlist generator.
 *						The returned string pointer is owned by the generator, do not free it.
 */
gn_error_t
gnplaylist_plgen_getdescription(
	gnpl_playlist_gen_handle_t	  hpl,
	const gn_uchar_t			**p_desc
	);


/*	gnplaylist_plgen_getisselectionbased
 *
 *	Report whether any of the criteria within the playlist generator are selection based.
 *	This may help your application determine if seed songs need to be passed in to the
 *	gnplaylist_generateplaylist_results function.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:				A playlist generator.
 *		p_isselectionbased:	On success, GN_TRUE if the generator contains any selection-based
 *							criteria, GN_FALSE otherwise.
 */
gn_error_t
gnplaylist_plgen_getisselectionbased(
	gnpl_playlist_gen_handle_t	 hpl,
	gn_bool_t					*p_isselectionbased
	);


/*	gnplaylist_plgen_setmatchmode
 *
 *	Sets the matchmode for multiple criteria to "match any" or "match all."
 *	Not necessary if the generator has only one criterion.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:			A playlist generator.
 *		mode:			The matchmode - gnpl_matchmode_match_all or gnpl_matchmode_match_any.
 */
gn_error_t
gnplaylist_plgen_setmatchmode(
	gnpl_playlist_gen_handle_t	hpl,
	gnpl_criteria_matchmode_t	mode
	);


/*	gnplaylist_plgen_getmatchmode
 *
 *	Gets the match mode for the playlist generator.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:			A playlist generator.
 *		p_mode:			On success, the matchmode for the generator.
 */
gn_error_t
gnplaylist_plgen_getmatchmode(
	gnpl_playlist_gen_handle_t	 hpl,
	gnpl_criteria_matchmode_t	*p_mode
	);


/*	gnplaylist_plgen_setsortresultsbyfield
 *
 *	Sets the field by which to sort the playlist results.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:	A playlist generator.
 *		field:	The field by which results should be sorted.
 *				Use gnpl_crit_field_first to clear sorting.
 */
gn_error_t
gnplaylist_plgen_setsortresultsbyfield(
	gnpl_playlist_gen_handle_t	hpl,
	gnpl_crit_field_t			field
	);


/*	gnplaylist_plgen_getsortresultsbyfield
 *
 *	Gets the field by which results will be sorted.
 *
 *	Return Value: GN_SUCCESS or error code. Returns PLMERR_NotFound if no field is set.
 *
 *	Parameters
 *		hpl:			A playlist generator.
 *		p_ret_field:	On success, the field that is set for sorting results.
 */
gn_error_t
gnplaylist_plgen_getsortresultsbyfield(
	gnpl_playlist_gen_handle_t	 hpl,
	gnpl_crit_field_t			*p_ret_field
	);


/*	gnplaylist_plgen_setautoupdate
 *
 *	Sets the autoupdate flag for the playlist generator.
 *	This is not used internally, but your application may use it to tell itself
 *	to re-generate the playlist when it is selected.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:			A playlist generator
 *		autoupdate:		GN_TRUE or GN_FALSE
 */
gn_error_t
gnplaylist_plgen_setautoupdate(
	gnpl_playlist_gen_handle_t	hpl,
	gn_bool_t					autoupdate
	);


/*	gnplaylist_plgen_getautoupdate
 *
 *	Gets the autoupdate flag for the playlist generator.  This is not used internally, but
 *	your application may use it.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:			A playlist generator.
 *		p_autoupdate:	On success, the value of the autoupdate flag for the generator.
 */
gn_error_t
gnplaylist_plgen_getautoupdate(
	gnpl_playlist_gen_handle_t	 hpl,
	gn_bool_t					*p_autoupdate
	);


/*	gnplaylist_plgen_set_exclude_list
 *
 *	Add a list of entrydata records to a playlist generator.  These track entries will
 *	be excluded from the playlist results
 *
 *	Pass exclude_list as GN_NULL or exclude_num as 0 to remove the excluded list from the
 *	generator.
 *
 *	Memory is allocated in the generator to copy the exclude_list.
 *
 *	Parameters
 *		hpl:				A valid playlist generator handle.
 *
 *		exclude_list:		An array of gnplaylist_entrydata_t pointers.
 *
 *		exclude_num:		The number of gnplaylist_entrydata_t records in the exclude_list.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_InvalidArg	cfg is not a valid configuration struct.
 *
 *		PLMERR_NoMemory		Not enough memory is available to allocate storage for the list.
 */
gn_error_t
gnplaylist_plgen_set_exclude_list(
	gnpl_playlist_gen_handle_t		 hpl,
	gnplaylist_entrydata_t			*exclude_list,
	gn_uint16_t						 exclude_num
	);


/*	gnplaylist_plgen_get_exclude_list
 *
 *	Return a copy of the exclude list, if any, from this playlist generator.
 *	If no exclude list exists the function will return GN_SUCCESS with exclude_num set to 0 and
 *	exclude_list set to GN_NULL.
 *
 *	Memory is allocated for the returned list and the developer is responsible for freeing the
 *	entries using gnplaylist_plgen_free_exclude_list.
 *
 *	Parameters
 *		hpl:				A valid playlist generator handle.
 *
 *		exclude_list:		Address of an gnplaylist_entrydata_t* array to recieve the list.
 *
 *		exclude_num:		Address of an gn_uint16_t to recieve the number of entries in the
 *							exclude_list.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_InvalidArg	Either cfg is not a valid configuration struct or exclude_list or
 *							exclude_num are null.
 *
 *		PLMERR_NoMemory		Not enough memory is available to allocate storage for exclude_list.
 */
gn_error_t
gnplaylist_plgen_get_exclude_list(
	gnpl_playlist_gen_handle_t		  hpl,
	gnplaylist_entrydata_t			**exclude_list,
	gn_uint16_t						 *exclude_num
	);


/*	gnplaylist_plgen_free_exclude_list
 *
 *	Free an exclude list created by gnplaylist_plgen_get_exclude_list or
 *	gnplaylist_morelikethis_cfg_get_exclude_list.
 *
 *	Parameters
 *		exclude_list:		array of gnplaylist_entrydata_t records.
 *
 *		exclude_num:		the number of entries in the exclude_list.
 *
 *	Return Value: GN_SUCCESS or error code:
 */
gn_error_t
gnplaylist_plgen_free_exclude_list(
	gnplaylist_entrydata_t			*exclude_list,
	gn_uint16_t						 exclude_num
	);


/*	gnplaylist_plgen_setrandom
 *
 *	Set the generated playlist randomness on or off.
 *
 *	Returns PLMERR_InvalidArg if the playlist handle is null, otherwise GN_SUCCESS.
 *
 *	Parameters
 *		hpl:		A valid playlist generator.
 *		random:		GN_TRUE  - randomize the generated playlist or
 *					GN_FALSE - generate a consistant playlist for the given criteria.
 *
 *	Playlist results are randomized by default.  The only good reason why you would ever
 *	want to turn randomization off is during system testing.  In general, do not use this call.
 */
gn_error_t
gnplaylist_plgen_setrandom(
	gnpl_playlist_gen_handle_t	hpl,
	gn_bool_t					random
	);


/*	gnplaylist_plgen_getrandom
 *
 *	Returns random flag setting for playlist.
 *
 *	Returns PLMERR_InvalidArg if the playlist handle is null, otherwise GN_SUCCESS.
 *
 *	Parameters
 *		hpl:		A valid playlist generator.
 *		random:		Address of a gn_bool_t to recieve the random flag value.
 */
gn_error_t
gnplaylist_plgen_getrandom(
	gnpl_playlist_gen_handle_t	hpl,
	gn_bool_t					*random
	);


/*	MARK:	Generator Lists
 *
 *	The Playlist subsystem maintains two generator lists holding stored playlist generators: the
 *	preset generator list and the user generator list.  The preset generator list is installed
 *	with the eMMS li-brary and cannot be modified. The user generator list is created and
 *	maintained by the applica-tion, allowing custom playlist generators to be defined according
 *	to the user's preferences.
 */

/*	gnplaylist_loadpresetgeneratorlist
 *
 *	Loads preset generators (not user editable) from disk. Returns a generator list handle.
 *	The returned handle is not owned by the caller and should not be freed.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		p_ret_preset_generator_list:	Returned handle to preset generators.
 *		p_num_gens:					Number of generators is returned here.
 *									This is optional.  Pass GN_NULL if you do not
 *									need the count.
 */
gn_error_t
gnplaylist_loadpresetgeneratorlist(
	gnpl_playlist_gen_list_handle_t	*p_ret_preset_generator_list,
	gn_size_t						*p_num_gens
	);


/*	gnplaylist_loadusergeneratorlist
 *
 *	Loads the user-editable playlist generators. Returns a generator list handle.
 *	The returned handle is not owned by the caller and should not be freed.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		p_ret_user_generator_list:	Returned handle to user playlist generators.
 *		p_num_gens:					Number of generators is returned here.
 *									This is optional.  Pass GN_NULL if you do not
 *									need the count.
 */
gn_error_t
gnplaylist_loadusergeneratorlist(
	gnpl_playlist_gen_list_handle_t	*p_ret_user_generator_list,
	gn_size_t						*p_num_gens
	);

/*	gnplaylist_saveusergeneratorlist
 *
 *	Saves user-editable playlist generators to disk.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		none
 */
gn_error_t
gnplaylist_saveusergeneratorlist(
	void
	);


/*	gnplaylist_getnumgenerators
 *
 *	Retrieves the number of playlist generators in a generator list.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		hpl_list:			Generator list.
 *		p_numgenerators:	On success returns the number of generators in the list.
 */
gn_error_t
gnplaylist_getnumgenerators(
	gnpl_playlist_gen_list_handle_t	 hpl_list,
	gn_uint16_t						*p_numgenerators
	);


/*	gnplaylist_getgeneratoratindex
 *
 *	Retrieves a specified playlist generator from a generator list.  The desired generator is
 *	identified by its index within the list.  The index is 0 based, and must be less than the
 *	list size returned by gnplaylist_getnumgenerators.
 *
 *	The caller should not free this playlist generator as it is managed as part of the list.
 *	If a generator is not found at the given index, the p_ret_generator pointer will be set
 *	to GN_NULL and the error return status will be PLMERR_NotFound.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		hpl_list:			Generator list.
 *		index:				Zero-based index of the generator to be retrieved.
 *		p_ret_generator:	On success returns the generator from the list.
 */
gn_error_t
gnplaylist_getgeneratoratindex(
	gnpl_playlist_gen_list_handle_t	 hpl_list,
	gn_uint16_t						 index,
	gnpl_playlist_gen_handle_t		*p_ret_generator
	);


/*	gnplaylist_addgenerator
 *
 *	Adds a playlist generator to a generator list at a specified index.  If the value supplied
 *	for p_index is GN_NULL or is greater than the number of generators in the list, the new
 *	generator is added to the end of the list.  On success, the value pointed to by p_index,
 *	if given, will be set to the index where the generator was stored.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		hpl_list:			Generator list.
 *		newgenerator:		A new, populated generator to be added to the list.
 *		p_index:			GN_NULL or index of where to place the generator in the list.
 */
gn_error_t
gnplaylist_addgenerator(
	gnpl_playlist_gen_list_handle_t	 hpl_list,
	gnpl_playlist_gen_handle_t		 newgenerator,
	gn_uint16_t						*p_index
	);


/*	gnplaylist_deletegenerator
 *
 *	Deletes a playlist generator from a generator list and frees all memory associated with it.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		hpl_list:			Generator list.
 *		p_generator:		A handle to a generator that exists in the list
 */
gn_error_t
gnplaylist_deletegenerator(
	gnpl_playlist_gen_list_handle_t	hpl_list,
	gnpl_playlist_gen_handle_t		p_generator
	);


/*	gnplaylist_backupusergeneratorlist
 *
 *	Make a backup of the user playlist generator database.
 *
 *	If a previous backup already exists, it is replaced by the new one.
 *
 *	Return Value: GN_SUCCESS or error code.
 *		EDBIMERR_NotInited	The integrity manager has not been initialized.
 *
 *	Parameters:				None
 */
gn_error_t
gnplaylist_backupusergeneratorlist(
	void
	);


/*	gnplaylist_revertusergeneratorlist
 *
 *	Replaces the user generator list with its backup.
 *
 *	Return Value: GN_SUCCESS or error code.
 *		EDBIMERR_NotInited	The integrity manager has not been initialized.
 *
 *	Parameters:				None
 */
gn_error_t
gnplaylist_revertusergeneratorlist(
	void
	);


/*	gnplaylist_deleteusergeneratorlist
 *
 *	Deletes the user generator list along with its backup, if any.
 *
 *	Return Value: GN_SUCCESS or error code.
 *		EDBIMERR_NotInited	The integrity manager has not been initialized.
 *
 *	Parameters:				None
 */
gn_error_t
gnplaylist_deleteusergeneratorlist(
	void
	);


/*	------------------------------------------------------------------------------------------
 *	MARK:	Generation Criteria
 *
 *	For a playlist generator to be functional, it must contain one or more generation criteria:
 *	rules for selecting the tracks to include in a generated playlist.  Criteria are referenced
 *	with opaque point-ers of type gnpl_crit_handle_t, declared in header file gn_playlist_types.h. 
 */
/*
	To set up a criterion, some of the following functions are required, and others are optional.
	The criterion, at a minimum, must have a field, a field type, and an operator.
	Most criteria will also have one primary parameter (unless it is selection-based).
	Some may have 2 or 3 parameters (depending on the operator chosen).

	Example: to set up a criterion describing artist equals "The Beatles" you would set
			field:		gnpl_crit_field_track_artist_name
			type:		gnpl_crit_field_type_string
			operator:	gnpl_crit_op_str_eq
			param1:		"The Beatles"

	Example: to set up a criterion describing playcount is between 1 and 10 you would set
			field:		gnpl_crit_field_track_playcount
			type:		gnpl_crit_field_type_num
			operator:	gnpl_crit_op_num_rang
			param1:		1
			param2:		10

	Example: to set up a criterion describing genre is similar to the selected item you would set
			field:		gnpl_crit_field_album_genrev2
			type:		gnpl_crit_field_type_enum
			operator:	gnpl_crit_op_enum_sim
			param1:		(param1 is determined at generation time.
						You must call set_isselectionbased to make this selection based).
			param2:		850	(how similar)
			param3:		15	(similarity window)
*/

/*	MARK:	Creating and Destroying Criteria
 *
 *	gnplaylist_crit_create_criterion
 *
 *	Allocate a new criterion.  The criterion should either be added to a playlist generator,
 *	or should be freed using gnplaylist_crit_free_criterion()
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_InvalidArg
 *					Unknown field identifier
 *
 *		PLMERR_PermissionError
 *					This field can not be used in a playlist criteria.
 *
 *		PLMERR_NoMemory
 *					Not enough memory available to allocate the playlist criteria.
 *
 *	Parameters
 *		p_h_crit:	On success, an allocated criterion.
 *		field:		The field upon which this criterion operates.
 *					Possible fields for gnpl_crit_field_t can be found in gn_playlist_enums.h.
 *		type:		The type of the field (number, string, date, enumeration).
 *					Possible types for gnpl_crit_type_t can be found in gn_playlist_enums.h.
 *		op:			The operator of the criterion.
 *					Possible operators for gnpl_crit_op_t can be found in gn_playlist_enums.h.
 */
gn_error_t
gnplaylist_crit_create_criterion(
	gnpl_crit_handle_t		*p_h_crit,
	gnpl_crit_field_t		 field,
	gnpl_crit_field_type_t	 type,
	gnpl_crit_op_t			 op
	);


/*	gnplaylist_crit_clone_criterion
 *
 *	Make a copy of a criterion. All parameters are identical to the source criterion.
 *	The criterion should either be added to a playlist generator or should be freed using
 *	gnplaylist_crit_free_criterion(). This may be useful if your application allows
 *	editing copies of playlist generators.
 *
 *	Error value, including PLMERR_NoMemory, or GN_SUCCESS.
 *
 *	Parameters
 *		h_crit:				The source criterion.
 *		p_ret_h_clonedcrit:	On success, a copy of the source criterion.
 *							Memory is allocated.
 */
gn_error_t
gnplaylist_crit_clone_criterion(
	gnpl_crit_handle_t	 h_crit,
	gnpl_crit_handle_t	*p_ret_h_clonedcrit
	);


/*	gnplaylist_crit_free_criterion
 *
 *	Frees an allocated criterion and sets its handle to GN_NULL.
 *	Note: If the criterion has been added to a playlist generator, you should not free it.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		h_crit:		An allocated criterion to be freed.
 */
gn_error_t
gnplaylist_crit_free_criterion(
	gnpl_crit_handle_t	*h_crit
	);


/*	MARK:	Criterion Attribute Access
 *
 *	gnplaylist_crit_setfield
 *
 *	Sets the field for a criterion.  Note, if you want to set a developer field higher than 3
 *	you must call gnplaylist_crit_setdevfieldnum instead of this function.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_InvalidArg
 *					Unknown field identifier
 *
 *		PLMERR_PermissionError
 *					This field can not be used in a playlist criteria. 
 *
 *	Parameters:
 *		h_crit:		A criterion.
 *		field:		A field.  See gn_playlist_enums.h for a list of valid fields.
 */
gn_error_t
gnplaylist_crit_setfield(
	gnpl_crit_handle_t	h_crit,
	gnpl_crit_field_t	field
	);


/*	gnplaylist_crit_getfield
 *
 *	Get the field identifier that is set in this criterion.  If the field returned is
 *	gnpl_crit_field_xdev, you need to call gnplaylist_crit_getdevfieldnum to find out which
 *	developer field it is.
 *
 *	If either gnpl_crit_field_xdev1, gnpl_crit_field_xdev2, or gnpl_crit_field_xdev3 were
 *	used in a call to gnplaylist_crit_setfield to set the field then that field identifier
 *	will be returned, not gnpl_crit_field_xdev.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		h_crit:		    A criterion.
 *      p_ret_field:    On success, the field that has been set for the criterion.
 */
gn_error_t
gnplaylist_crit_getfield(
	gnpl_crit_handle_t		 h_crit,
	gnpl_crit_field_t		*p_ret_field
	);


/*	gnplaylist_crit_setdevfieldnum
 *
 *	Sets the field for a criterion to a developer field. A developer field number greater than
 *	0 must be specified. This overrides the criterion's field if it was set in the allocation
 *	or using gnplaylist_crit_setfield.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		h_crit:			A criterion.
 *		devfieldnum:	The developer field number
 */
gn_error_t
gnplaylist_crit_setdevfieldnum(
	gnpl_crit_handle_t	h_crit,
	gn_uint32_t			devfieldnum
	);


/*	gnplaylist_crit_getdevfieldnum
 *
 *	Gets the developer field number for a criterion if the field is a developer field.
 *	If gnplaylist_crit_getfield reveals a field value of gnpl_crit_field_xdev, then you should
 *	call this function to find out which developer field number it is.
 *
 *	Return Value:
 *		GN_SUCCESS or error code.
 *		GNERR_NotFound if the criterion's field is not a developer field.
 *
 *	Parameters
 *		h_crit:				A criterion.
 *		p_ret_devfieldnum:	On success, the developer field number,
 */
gn_error_t
gnplaylist_crit_getdevfieldnum(
	gnpl_crit_handle_t		 h_crit,
	gn_uint32_t				*p_ret_devfieldnum
	);


/*	gnplaylist_crit_settype
 *
 *	Sets the type of the field for a criterion.  This determines which operators are valid for
 *	this criterion.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		h_crit:		A criterion.
 *		type:		A field type (number, string, enumeration, or date. See gn_playlist_enums.h)
 */
gn_error_t
gnplaylist_crit_settype(
	gnpl_crit_handle_t		h_crit,
	gnpl_crit_field_type_t	type
	);


/*	gnplaylist_crit_gettype
 *
 *	Gets the field type set for a criterion.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		h_crit:		   A criterion.
 *      p_ret_type:    On success, the field type set for the criterion.
 */
gn_error_t
gnplaylist_crit_gettype(
	gnpl_crit_handle_t		 h_crit,
	gnpl_crit_field_type_t	*p_ret_type
	);


/*	gnplaylist_crit_setop
 *
 *	Sets the operator for a criterion.  Only operators for the correct field type for the
 *	criterion's field will work.  Possible operators can be found in gn_playlist_enums.h.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		h_crit:		A criterion
 *		op:			An operator (gnpl_crit_op<...>) that is valid for the field type of this
 *					criterion.
 */
gn_error_t
gnplaylist_crit_setop(
	gnpl_crit_handle_t	h_crit,
	gnpl_crit_op_t		op
	);


/*	gnplaylist_crit_getop
 *
 *	Gets the operator set for a criterion.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		h_crit:		 A criterion.
 *      p_ret_op:    On success, the operator set for the criterion.
 */
gn_error_t
gnplaylist_crit_getop(
	gnpl_crit_handle_t	 h_crit,
	gnpl_crit_op_t		*p_ret_op
	);


/*	gnplaylist_crit_setop_function
 *
 *	Sets the operator function definition for a criterion.
 *
 *	This call is currently supported only for the similarity operator on fields defined
 *	with a data type of gnpl_crit_field_type_key_ivalue_array.
 *
 *	Return Value: GN_SUCCESS or error code.
 *	PLMERR_InvalidArg
 *					Either h_crit is GN_NULL or func is not a valid similarity function.
 *
 *	Parameters
 *		h_crit:		A criterion
 *		func:		A similarity function.
 *					For now, only GNPL_CRIT_SIMILARITY_FUNCTION_1 is supported.
 */
gn_error_t
gnplaylist_crit_setop_function(
	gnpl_crit_handle_t				h_crit,
	gnpl_crit_similarity_function_t	func
	);


/*	gnplaylist_crit_getop_function
 *
 *	Gets the operator function definition that is set for a criterion.
 *
 *	This call is currently supported only for the similarity operator on fields defined
 *	with a data type of gnpl_crit_field_type_key_ivalue_array.
 *
 *	Return Value: GN_SUCCESS or error code.
 *	PLMERR_InvalidArg
 *					Either h_crit or p_func are GN_NULL
 *
 *	Parameters
 *		h_crit:		A criterion.
 *      p_func:		On success, the operator function set for the criterion.
 *					For now, only GNPL_CRIT_SIMILARITY_FUNCTION_1 is supported.
 */
gn_error_t
gnplaylist_crit_getop_function(
	gnpl_crit_handle_t				 h_crit,
	gnpl_crit_similarity_function_t	*p_func
	);


/*	gnplaylist_crit_setfield_key
 *
 *	Set the key element for a gnpl_crit_field_type_key_ivalue_array field for this criterion.
 *
 *	The field for this criterion must already have been set by a call to gnplaylist_crit_setfield()
 *	and the type of the field that was set must be gnpl_crit_field_type_key_ivalue_array.
 *
 *	The key specified here is a public display id for the field that is set for this criteria.
 *	It is mapped internally to a master id appropriate for the field.
 *
 *	Return Value: GN_SUCCESS or error code:
 *	PLMERR_InvalidArg
 *			Either the criteria handle is null or the field is either not set or is not a
 *			gnpl_crit_field_type_key_ivalue_array.
 *
 *	Parameters:
 *		h_crit:		A criterion handle.
 *		key:		A key element to set.
 */
gn_error_t
gnplaylist_crit_setfield_key(
	gnpl_crit_handle_t	h_crit,
	gn_uint32_t			key
	);


/*	gnplaylist_crit_getfield_key
 *
 *	Retrieve the key element of a gnpl_crit_field_type_key_ivalue_array field set for this criterion.
 *
 *	The key returned here is a public display id for the field that is set for this criteria.
 *	It is mapped internally from a master id to the appropriate display id for the field.
 *
 *	Return Value: GN_SUCCESS or error code:
 *	PLMERR_InvalidArg
 *			Either the criteria handle or p_key are null or the criteria does not have a
 *			set field or the field is not a gnpl_crit_field_type_key_ivalue_array.
 *
 *	Parameters:
 *		h_crit:		A criterion handle.
 *		p_key:		Address of an integer that will recieve the returned key.
 */
gn_error_t
gnplaylist_crit_getfield_key(
	gnpl_crit_handle_t	 h_crit,
	gn_uint32_t			*p_key
	);


/*	gnplaylist_crit_setintparam
 *
 *	Sets one of the three parameters for the criterion as integers.
 *
 *	Depending on the field and operator for the criterion, it may require 1, 2, or 3 parameters.
 *	Only gnpl_crit_op_enum_sim requires all 3 parameters gnpl_crit_op_num_rang and
 *	gnpl_crit_op_date_rang require 2 parameters.  All others require only gnpl_crit_param_1.
 *
 *	In general, gnpl_crit_param_1 is for the primary value for range operators and
 *	gnpl_crit_param_2 is the end value. For similarity, gnpl_crit_param_2 is "how similar"
 *	and gnpl_crit_param_3 is the "similarity window"
 *
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		h_crit:			A criterion.
 *		whichparam:		Which parameter to set (gnpl_crit_param_1, gnpl_crit_param_2,
 *						or gnpl_crit_param_3).
 *		param:			The integer value for the parameter.
 */
gn_error_t
gnplaylist_crit_setintparam(
	gnpl_crit_handle_t		h_crit,
	gnpl_crit_param_num_t	whichparam,
	gn_int32_t				param
	);


/*	gnplaylist_crit_getintparam
 *
 *	Gets an integer parameter value from the criterion, if one has been set.
 *	The function returns 0 if no integer parameter has been set, but may return an integer
 *	interpretation of the date if a date parameter has been set.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		h_crit:		        A criterion.
 *		whichparam:		    Which parameter (gnpl_crit_param_1, gnpl_crit_param_2, or
 *							gnpl_crit_param_3)
 *      p_ret_intparam_val: On success, the value of the parameter specified by whichparam
 */
gn_error_t
gnplaylist_crit_getintparam(
	gnpl_crit_handle_t		 h_crit,
	gnpl_crit_param_num_t	 whichparam,
	gn_int32_t				*p_ret_intparam_val
	);


/*	gnplaylist_crit_setstrparam
 *
 *	Sets the main parameter of a criterion to a string value.
 *	Only str operators require string parameters to be set.  The string operators require just
 *	one parameter, so only gnpl_crit_param_1 is currently valid for this function.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		h_crit:			A criterion
 *		whichparam:		Which parameter to set should be (gnpl_crit_param_1).
 *		param:			The string value for the parameter.
 *						Memory is allocated.
 */
gn_error_t
gnplaylist_crit_setstrparam(
	gnpl_crit_handle_t		 h_crit,
	gnpl_crit_param_num_t	 whichparam,
	const gn_uchar_t		*param
	);


/*	gnplaylist_crit_getstrparam
 *
 *	Gets a string parameter value from the criterion. If no string parameter has been set,
 *	will return GN_NULL;
 *
 *	Return Value: GN_SUCCESS, PLMERR_InvalidArg, or PLMERR_NoMemory.
 *
 *	Parameters
 *		h_crit:				A criterion.
 *		whichparam:			Which parameter (only gnpl_crit_param_1 is valid for string fields)
 *		p_ret_str_param:	On success, a pointer to allocated memory containing the string
 *							value of the parameter specified by whichparam.  The user is
 *							responsible for freeing p_ret_str_param if it is not GN_NULL.
 *                          Use gnplaylist_crit_freestrparam to free the returned string
 */
gn_error_t
gnplaylist_crit_getstrparam(
	gnpl_crit_handle_t		  h_crit,
	gnpl_crit_param_num_t	  whichparam,
	gn_uchar_t				**p_ret_str_param
	);


/*	gnplaylist_crit_freestrparam
 *
 *	Frees a string parameter value returned from gnplaylist_crit_getstrparam.
 *
 *	Return Value: GN_SUCCESS, 
 *
 *	Parameters
 *		str_param:			The string to free
 */
gn_error_t
gnplaylist_crit_freestrparam(
	gn_uchar_t		*str_param
	);


/*	gnplaylist_crit_setdateparam
 *
 *	Sets parameter 1 or parameter 2 of a criterion to a date value.
 *
 *	Most date operators require just one parameter (gnpl_crit_param_1).  The operator
 *	gnpl_crit_op_date_rang takes two parameters, so this function will need to be called
 *	for each of gnpl_crit_param_1 and gnpl_crit_param_2.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		h_crit:			A criterion.
 *		whichparam:		Which parameter to set should be (gnpl_crit_param_1 or gnpl_crit_param_2).
 *		dateparam:		The date value for the parameter (in gnpl_timestamp_t form).
 */
gn_error_t
gnplaylist_crit_setdateparam(
	gnpl_crit_handle_t		 h_crit,
	gnpl_crit_param_num_t	 whichparam,
	gnpl_timestamp_t		*dateparam
	);


/*	gnplaylist_crit_getdateparam
 *
 *	Gets a date parameter value from the criterion.  If no date parameter has been set this
 *	will return an unpopulated date structure, or an interpretation of the integer value if
 *	an integer parameter has been set.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		h_crit:		        A criterion.
 *		whichparam:		    Which parameter (only gnpl_crit_param_1 or gnpl_crit_param_2)
 *      p_ret_dateparam:    On success, the value of the parameter specified by whichparam,
 *							as a timestamp.
 */
gn_error_t
gnplaylist_crit_getdateparam(
	gnpl_crit_handle_t		 h_crit,
	gnpl_crit_param_num_t	 whichparam,
	gnpl_timestamp_t		*p_ret_dateparam
	);


/*	DEPRECATED:	gnplaylist_crit_setselection_based
 *	It is recommended that you use gnplaylist_crit_set_selection_type() instead of this function.
 *
 *	Set the criterion to be selection based.  When a criterion is selection-based, the primary
 *	parameter (gnpl_crit_param1) is not set inside the criterion.  Instead, it is determined at
 *	playlist generation time by the passed-in seed song(s).
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		h_crit:				A criterion
 *		bIsSelectionBased:	GN_TRUE to set the criterion to be selection-based,
 *							GN_FALSE to clear the flag.
 */
gn_error_t
gnplaylist_crit_setselection_based(
	gnpl_crit_handle_t	h_crit,
	gn_bool_t			bIsSelectionBased
	);


/*	DEPRECATED:	gnplaylist_crit_getselection_based
 *	It is recommended that you use gnplaylist_crit_get_selection_type() instead of this function.
 *
 *	Gets the selection-based flag from the criterion.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		h_crit:		                A criterion
 *      p_ret_bIsSelectionBased:    On success, GN_TRUE if the criterion is selection-based;
 *									GN_FALSE otherwise
 */
gn_error_t
gnplaylist_crit_getselection_based(
	gnpl_crit_handle_t		 h_crit,
	gn_bool_t				*p_ret_bIsSelectionBased
	);


/*	gnplaylist_crit_set_selection_type
 *
 *	Set the seed song selection type for a playlist criterion.  A playlist criteria can
 *	specify that the selection be based on one or more seed songs.  Further, you may
 *	request that the seed song(s) be included or excluded from the result set.
 *
 *	Return Value: GN_SUCCESS or error code.
 *		PLMERR_InvalidArg	h_crit is GN_NULL or selection_type is invalid.
 *
 *	Parameters
 *		h_crit:				A criterion
 *		selection_type:		One of the following selection type options:
 *
 *			GNPL_CRITERION_NOT_SELECTION_BASED
 *				Mark the criterion as not based on a seed song.
 *				Same as: gnplaylist_crit_setselection_based( h_crit, GN_FALSE )
 *
 *			GNPL_CRITERION_IS_SELECTION_BASED
 *				Mark the criterion as being based on one or more seed songs.
 *				The seed songs may or may not be included in the result set
 *				depending on randomization and song count limits
 *				Same as: gnplaylist_crit_setselection_based( h_crit, GN_TRUE )
 *
 *			GNPL_CRITERION_INCLUDE_SEED_SELECTION
 *				Mark the criterion as being based on one or more seed songs.
 *				The seed songs will always be included in the result set.
 *
 *			GNPL_CRITERION_TOP_SEED_SELECTION
 *				Mark the criterion as being based on one or more seed songs.
 *				The seed songs will always be included as the first songs in the
 *				result set.
 *
 *			GNPL_CRITERION_EXCLUDE_SEED_SELECTION
 *				Mark the criterion as being based on one or more seed songs.
 *				The seed songs will not be included in the result set.
 */
gn_error_t
gnplaylist_crit_set_selection_type(
	gnpl_crit_handle_t		h_crit,
	gnpl_crit_selection_t	selection_type
	);


/*	gnplaylist_crit_get_selection_type
 *
 *	Get the seed song selection type for a playlist criterion.
 *
 *	Return Value: GN_SUCCESS or error code.
 *		PLMERR_InvalidArg	Either h_crit or selection_type is GN_NULL.
 *
 *	Parameters
 *		h_crit:				A criterion
 *		selection_type:		Address of a gnpl_crit_selection_t variable that will be set to
 *							one of the selection type options.
 */
gn_error_t
gnplaylist_crit_get_selection_type(
	gnpl_crit_handle_t		 h_crit,
	gnpl_crit_selection_t	*selection_type
	);


/*	gnplaylist_crit_getorder
 *
 *	Gets the order that has been set for a criterion.  Order is optional, and is available
 *	for your application's benefit.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		h_crit:		    A criterion.
 *      p_ret_order:    On success, the order that has been set for the criterion.
 */
gn_error_t
gnplaylist_crit_getorder(
	gnpl_crit_handle_t		 h_crit,
	gn_uint16_t				*p_ret_order
	);


/*	gnplaylist_crit_setdescription
 *
 *	Sets a textual description for the criterion.
 *
 *	Error value, including PLMERR_NoMemory, or GN_SUCCESS.
 *
 *	Parameters
 *		h_crit:			A criterion.
 *		desc:			The description of the criterion.
 *						Memory is allocated.
 */
gn_error_t
gnplaylist_crit_setdescription(
	gnpl_crit_handle_t	 h_crit,
	const gn_uchar_t	*desc
	);


/*	gnplaylist_crit_getdescription
 *
 *	Gets the description of the criterion.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		h_crit:		    A criterion
 *		p_ret_desc:		On success, the description for the criterion.
 *						The returned string pointer is owned by the criterion, do not free it.
 */
gn_error_t
gnplaylist_crit_getdescription(
	gnpl_crit_handle_t	  h_crit,
	const gn_uchar_t	**p_ret_desc
	);


/*	gnplaylist_crit_setweight
 *
 *	Sets the weight of a criterion - for a generator set to matchmode:any, weights can
 *	prioritize some of the criteria over others.
 *	This function is currently unsupported.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		h_crit:		A criterion.
 *		weight:		A weight, expressed as an integer.  Only the relative value of the weight
 *					compared to weights of other criteria is relevant.
 */
gn_error_t
gnplaylist_crit_setweight(
	gnpl_crit_handle_t	h_crit,
	gn_uint16_t			weight
	);


/*	gnplaylist_crit_getweight
 *
 *	Gets the weight set for a criterion.  Weight is not currently used by the playlist manager.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		h_crit:		     A criterion.
 *      p_ret_weight:    On success, the weight that has been set for the criterion.
 */
gn_error_t
gnplaylist_crit_getweight(
	gnpl_crit_handle_t	 h_crit,
	gn_uint16_t			*p_ret_weight
	);


/*	MARK:	Criterion Management
 *
 *	Once you have created a criterion, you will want to add it to a playlist generator.
 *	Use the following functions to manage criterion within a playlist generator.
 */

/*	gnplaylist_plgen_addcriterion
 *
 *	Adds one criterion to the playlist generator's list of criteria.
 *
 *	If *p_order > 0, the function replaces any existing ordered item with this one
 *	(freeing the old one). If *p_order = 0, or p_order is GN_NULL, the function assigns
 *	the criterion an order larger than every present order, and sets the value of
 *	*p_order with the new order.
 *
 *	Note that when a criterion is added to a playlist generator the memory for that criterion
 *	is owned by the generator.  You must not free criteria after you have added them to a
 *	generator.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:		A valid playlist generator.
 *		crit:		A populated criterion
 *		p_order:	Optional, if not GN_NULL, p_order will be populated with the actual order.
 */
gn_error_t
gnplaylist_plgen_addcriterion(
	gnpl_playlist_gen_handle_t	 hpl,
	gnpl_crit_handle_t			 crit,
	gn_uint16_t					*p_order
	);


/*	gnplaylist_plgen_getcritcount
 *
 *	Gets the number of criteria contained in this playlist generator.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:			A valid playlist generator.
 *		p_num_crit:		On return, populated with the number of criteria.
 */
gn_error_t
gnplaylist_plgen_getcritcount(
	gnpl_playlist_gen_handle_t	 hpl,
	gn_uint16_t					*p_num_crit
	);


/*	gnplaylist_plgen_getcritatindex
 *
 *	Retrieves a criterion at an index in the playlist generator.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:			A valid playlist generator.
 *		index:			A number between 0 and the number of criteria - 1 (0-based).
 *		p_ret_h_crit:	On success, the criterion from the playlist generator.
 *						Note - this is not a copy, and any operations performed on this
 *						criterion will be in the generator. Also, the memory for this
 *						criterion is still managed by the host playlist generator.
 */
gn_error_t
gnplaylist_plgen_getcritatindex(
	gnpl_playlist_gen_handle_t	 hpl,
	gnpl_crit_handle_t			*p_ret_h_crit,
	gn_uint16_t					 index
	);


/*	gnplaylist_plgen_getcritmatchingorder
 *
 *	Retrieves a criterion with a specified order in the playlist generator. You may want to use
 *	this instead of gnplaylist_plgen_getcritatindex if your application needs to keep track of
 *	an ordering of criteria outside of the playlist generator's concept of index (which may
 *	change internally).
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl				A valid playlist generator.
 *		p_ret_h_crit	On success, the criterion from the playlist generator. Note: this is
 *						not a copy, and any operations performed on this criterion will affect
 *						the criterion in the generator. Also, the memory for this criterion is
 *						still managed by the host playlist generator.
 *		order			A number between 1 and the number of criteria. (1-based.)
 */
gn_error_t
gnplaylist_plgen_getcritmatchingorder(
	gnpl_playlist_gen_handle_t	 hpl,
	gnpl_crit_handle_t			*p_ret_h_crit,
	gn_uint16_t					 order
	);


/*	gnplaylist_plgen_removecriterion
 *
 *	Removes and frees a criterion from a playlist generator.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:					A valid playlist generator.
 *		p_del_this_crit:		A criterion that exists in the playlist generator.
 *								On success, this is be freed and invalidated.
 */
gn_error_t
gnplaylist_plgen_removecriterion(
	gnpl_playlist_gen_handle_t	 hpl,
	gnpl_crit_handle_t			*p_del_this_crit
	);


/*	gnplaylist_plgen_removecritmatchingorder
 *
 *	Removes and frees a criterion from a playlist generator matching the order parameter.
 *	Like gnplaylist_plgen_removecriterion, but looks for one with a particular order.
 *	On success, the found criterion is removed from the playlist generator, memory associated
 *	with the criterion is freed.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:		A valid playlist generator.
 *		order:		An index into the list of criteria in the playlist generator.
 */
gn_error_t
gnplaylist_plgen_removecritmatchingorder(
	gnpl_playlist_gen_handle_t	hpl,
	gn_uint16_t					order
	);


/*	gnplaylist_plgen_clearcriteria
 *
 *	Removes and frees *all* criteria from a playlist generator.  You need not call this
 *	when deleting a playlist generator, gnplaylist_plgen_freeplaylistgen will manage the memory.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:		A valid playlist generator.
 */
gn_error_t
gnplaylist_plgen_clearcriteria(
	gnpl_playlist_gen_handle_t	hpl
	);


/*	------------------------------------------------------------------------------------------
 *	MARK:	Limits and Ranking
 *
 *	This section describes functions for specifying limits on generated playlists and for ranking
 *	the criteria used to generate them.
 */

/*	MARK:	Setting Playlist Limits
 *
 *
 *	gnplaylist_plgen_setsongslimit
 *
 *	Set the generated playlist maximum songs limit.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:		A valid playlist generator.
 *		limit:		The limit, in number of songs for the generated playlist.
 */
gn_error_t
gnplaylist_plgen_setsongslimit(
	gnpl_playlist_gen_handle_t	hpl,
	gn_uint32_t					limit
	);


/*	gnplaylist_plgen_getsongslimit
 *
 *	Get the generated playlist maximum songs limit.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:		A valid playlist generator.
 *		plimit:		On success, the limit, in number of songs for the generated playlist.
 */
gn_error_t
gnplaylist_plgen_getsongslimit(
	gnpl_playlist_gen_handle_t	 hpl,
	gn_uint32_t					*plimit
	);


/*	gnplaylist_plgen_setminslimit
 *
 *	Set the generated playlist limit in minutes.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:		A valid playlist generator.
 *		limit:		The limit, in minutes for the generated playlist.
 */
gn_error_t
gnplaylist_plgen_setminslimit(
	gnpl_playlist_gen_handle_t	hpl,
	gn_uint32_t					limit
	);


/*	gnplaylist_plgen_getminslimit
 *
 *	Retrieve the generated playlist limit in minutes.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:		A valid playlist generator.
 *		plimit:		On success, the limit, in minutes for the generated playlist.
 */
gn_error_t
gnplaylist_plgen_getminslimit(
	gnpl_playlist_gen_handle_t	 hpl,
	gn_uint32_t					*plimit
	);


/*	gnplaylist_plgen_setkblimit
 *
 *	Set the generated playlist maximum kilobyte limit.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:		A valid playlist generator
 *		limit:		The limit, in kilobytes for the generated playlist.
 */
gn_error_t
gnplaylist_plgen_setkblimit(
	gnpl_playlist_gen_handle_t	hpl,
	gn_uint32_t					limit
	);


/*	gnplaylist_plgen_getkblimit
 *
 *	Get the generated playlist maximum kilobyte limit.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:		A valid playlist generator.
 *		plimit:		On success, the limit, in kilobytes for the generated playlist.
 */
gn_error_t
gnplaylist_plgen_getkblimit(
	gnpl_playlist_gen_handle_t	 hpl,
	gn_uint32_t					*plimit
	);


/*	MARK:	Setting Per-Field Limits
 *
 *	In addition to overall playlist limits, a playlist generator can optionally have one or more
 *	per-field limits specifying the maximum number of tracks that may contain the same value for
 *	a particular field.  You can use these to generate playlists with more varied results: for
 *	example, you can limit a generated playlist to no more than two tracks per album or four tracks
 *	per artist.  This section describes the functions for specifying such per-field limits. 
 */

/*	gnplaylist_plgen_addlimitperfield
 *
 *	Add a per-field limit to a playlist generator.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:		A valid playlist generator.
 *		field:		The field to limit.
 *      limit:      The limit value. In other words, the number of songs allowed with the
 *					same value for that field
 */
gn_error_t
gnplaylist_plgen_addlimitperfield(
	gnpl_playlist_gen_handle_t	hpl,
	gnpl_crit_field_t			field,
	gn_uint32_t					limit
	);


/*	gnplaylist_plgen_getlimitperfield
 *
 *	Retrieve a per-field limit from a playlist generator.
 *
 *	Return Value: GN_SUCCESS or error code.
 *	GNERR_NotFound if no limit had been set for the specified field.
 *
 *	Parameters
 *		hpl:		    A valid playlist generator.
 *		field:		    The field.
 *      p_ret_limit:    On success, the limit for the specified field.
 */
gn_error_t
gnplaylist_plgen_getlimitperfield(
	gnpl_playlist_gen_handle_t	 hpl,
	gnpl_crit_field_t			 field,
	gn_int32_t					*p_ret_limit
	);


/*	gnplaylist_plgen_getalllimitsperfield
 *
 *	Retrieve all per-field limits in two corresponding arrays of fields and limits.
 *  If num_limits comes back > 0, the caller must free the arrays of fields and limits
 *  (using gnplaylist_plgen_freealllimitsperfield())
 *
 *	Return Value: GN_SUCCESS or error code.
 *	Returns GNERR_NotFound if no limit had been set for the specified field.
 *
 *	Parameters
 *		hpl:		                    A valid playlist generator.
 *      pp_ret_allocated_fields_arr:    On success, an array of all of the fields that have
 *										per-field limits set.
 *      pp_ret_allocated_limits_arr:    On success, an array of the limits for each of the fields
 *										that have per-field limits set.
 *		p_ret_numlimits:	            On success, the number of per-field limits in the
 *										playlist generator.
 */
gn_error_t
gnplaylist_plgen_getalllimitsperfield(
	gnpl_playlist_gen_handle_t	  hpl,
	gnpl_crit_field_t			**pp_ret_allocated_fields_arr,
	gn_int32_t					**pp_ret_allocated_limits_arr,
	gn_uint16_t					 *p_ret_numlimits
	);


/*	gnplaylist_plgen_removelimitperfield
 *
 *	Clears a per-field limit from a playlist generator.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:		A valid playlist generator.
 *		field:		The field for which to clear per-field limits.
 */
gn_error_t
gnplaylist_plgen_removelimitperfield(
	gnpl_playlist_gen_handle_t	hpl,
	gnpl_crit_field_t			field
	);


/*	gnplaylist_plgen_clearalllimitsperfield
 *
 *  Clears all per-field limits in a playlist generator.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:			A valid playlist generator.
 */
gn_error_t
gnplaylist_plgen_clearalllimitsperfield(
	gnpl_playlist_gen_handle_t	hpl
	);


/*	gnplaylist_plgen_freealllimitsperfield
 *
 *	Free the arrays allocated by gnplaylist_plgen_getalllimitsperfield
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *      p_allocated_fields_arr:		    the array of fields to be freed.
 *      p_allocated_limits_arr:		    the array of limits to be freed.
 */
gn_error_t
gnplaylist_plgen_freealllimitsperfield(
	gnpl_crit_field_t			*p_allocated_fields_arr,
	gn_int32_t					*p_allocated_limits_arr
	);


/*	MARK:	Defining Ranking Criteria
 *
 *
 *	gnplaylist_rank_crit_new_rank
 *
 *  Creates a new ranking criterion for a playlist generator.  Field must be specified during
 *	creation. The other APIs below allow you to change the rank_order (default is ascending),
 *	the rank_weight (only applicable for fields which support similarity), or the ancillary
 *	order (which determines tie-breaker order for non-weighted ranking criteria).
 *
 *	Memory is allocated by this function, and if the rank is not successfully attached to a
 *	playlist generator, it should be freed using gnplaylist_rank_crit_free_rank.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_InvalidArg
 *					Unknown field identifier
 *
 *		PLMERR_PermissionError
 *					This field can not be used for playlist ranking.
 *
 *		PLMERR_NoMemory
 *					Not enough memory available to allocate the ranking criterion.
 *
 *	Parameters
 * 		p_ret_rank		On success, an allocated ranking criterion with the field specified.
 *						By default the ancillary order is 0, the weight is absent (i.e. 0),
 *						and the rank order is ascending.
 *		field			The field by which to rank the results.
 */
gn_error_t
gnplaylist_rank_crit_new_rank(
	gnplaylist_rank_crit_handle_t	*p_ret_rank,
	gnpl_crit_field_t				 field
	);


/*	gnplaylist_rank_crit_free_rank
 *
 *  Free a ranking criterion.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 * 		p_rank		The ranking criterion to free.
 */
gn_error_t
gnplaylist_rank_crit_free_rank(
	gnplaylist_rank_crit_handle_t	*p_rank
	);


/*	gnplaylist_rank_crit_set_field
 *
 *  Sets the field to rank by for a ranking criterion.  Field can be any criterion field,
 *	common ones are:
 *		Unweighted:
 *
 *		gnpl_crit_field_file_lastplayed_date,
 *		gnpl_crit_field_file_created_date,
 *		gnpl_crit_field_track_genrev2,
 *		gnpl_crit_field_track_playcount,
 *		gnpl_crit_field_track_myrating
 *
 *		Weighted:
 *
 *		gnpl_crit_field_track_genrev2,
 *		gnpl_crit_field_artist_era,
 *		gnpl_crit_field_artist_type,
 *		gnpl_crit_field_artist_region
 *
 *	Fields are usually set when the ranking criterion is created with
 *	gnplaylist_rank_crit_new_rank; this allows changing of the field after it has been created.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_InvalidArg
 *					Unknown field identifier
 *
 *		PLMERR_PermissionError
 *					This field can not be used for playlist ranking.
 *
 * Parameters:
 * 		rank:	An allocated ranking criterion.
 *		field:	The field by which to rank the results.
 */
gn_error_t
gnplaylist_rank_crit_set_field(
	gnplaylist_rank_crit_handle_t	rank,
	gnpl_crit_field_t				field
	);


/*	gnplaylist_rank_crit_get_field
 *
 *  Accessor function for getting the field value from a ranking criterion
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 * 		rank:			A ranking criterion either allocated or retrieved from a playlist
 *						generator.
 *		p_ret_field:	On success, the field for the ranking criterion
 */
gn_error_t
gnplaylist_rank_crit_get_field(
	gnplaylist_rank_crit_handle_t	 rank,
	gnpl_crit_field_t				*p_ret_field
	);


/*	gnplaylist_rank_crit_set_sort_order
 *
 *  Sets the sort order for a ranking criterion (gnpl_rank_order_ascending or
 *	gnpl_rank_order_ascending)  For ascending - highest values will be preferred, for
 *	descending, lowest values will be preferred.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 * 		rank:		An allocated ranking criterion.
 *		rank_order:	gnpl_rank_order_ascending (prefer highest values)
 *					or gnpl_rank_order_descending (prefer lowest values)
 */
gn_error_t
gnplaylist_rank_crit_set_sort_order(
	gnplaylist_rank_crit_handle_t	rank,
	gnpl_rank_order_t				sort_order
	);


/*	gnplaylist_rank_crit_get_sort_order
 *
 *  Accessor function for getting the sort order value from a ranking criterion
 *	The returned sort order will be one of these defined orders:
 *		gnpl_rank_order_none
 *		gnpl_rank_order_ascending
 *		gnpl_rank_order_descending
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 * 		rank:				A ranking criterion either allocated or retrieved from a
 *							playlist generator.
 *		sort_order:			On success, the sort order for the ranking criterion.
 */
gn_error_t
gnplaylist_rank_crit_get_sort_order(
	gnplaylist_rank_crit_handle_t	 rank,
	gnpl_rank_order_t				*sort_order
	);


/*	gnplaylist_rank_crit_set_weight
 *
 *	Sets the weight to rank by for a weighted ranking criterion.
 *	This is only applicable for weighted ranking criterion, and will only work with the following
 *	fields:
 *		gnpl_crit_field_track_genrev2,
 *		gnpl_crit_field_artist_era,
 *		gnpl_crit_field_artist_type,
 *		gnpl_crit_field_artist_region
 *
 *	Weight can be any number greater than 0 (less than 100 is recommended), if multiple weighted
 *	criterion with differing weights are present, the playlist generation will give more
 *	preference to ranking criteria with higher weight values.  Unweighted ranking criteria are
 *	still used as tiebreakers even when weighted ranking criteria are present.
 *
 *	Your application is unlikely to need to adjust weights for ranking criteria, as the
 *	"morelikethis" functions manage weighted criteria internally.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 * 		rank:	An allocated ranking criterion.
 *		weight:	Any positive number, usually between 1 and 100.
 */
gn_error_t
gnplaylist_rank_crit_set_weight(
	gnplaylist_rank_crit_handle_t	rank,
	gn_int32_t						weight
	);


/*	gnplaylist_rank_crit_get_weight
 *
 *  Accessor function for getting the field value from a weighted ranking criterion
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 * 		rank:			A ranking criterion either allocated or retrieved from a playlist
 *						generator.
 *		p_ret_weight:	On success, the weight for the weighted ranking criterion
 */
gn_error_t
gnplaylist_rank_crit_get_weight(
	gnplaylist_rank_crit_handle_t	 rank,
	gn_int32_t						*p_ret_weight
	);


/*	gnplaylist_rank_crit_set_ancillary_order
 *
 *  Sets the ancillary order for an unweighted ranking criterion that is used as a tiebreaker.
 *	This is only applicable for ranking criterion with no weights, and is *not* applicable for
 *	the following fields:
 *
 *		gnpl_crit_field_track_genrev2,
 *		gnpl_crit_field_artist_era,
 *		gnpl_crit_field_artist_type,
 *		gnpl_crit_field_artist_region
 *
 *	Ancillary order is relevant when you have more than one unweighted criterion - the one with
 *	the lowest ancillary order will be used first to prioritize tracks (for cut-offs), and in
 *	the event of a tie for the values of one ranking field, the ranking criterion with the next
 *	ancillary order will be used.  For example, you may want to prefer tracks that are highest
 *	in playcount, and use album popularity and track popularity as tiebreakers.
 *
 *	Note that if unweighted ranking criteria are present in addition to weighted ranking
 *	criteria, the weighted criteria automatically get most precedence, and unweighted are
 *	treated as tiebreakers.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 * 		rank:					An allocated ranking criterion.
 *		rank_ancillary_order:	The tiebreaker order - 0 for primary ranking criterion,
 *								1 for first tiebreaker, 2 for secondary, etc.
 */
gn_error_t
gnplaylist_rank_crit_set_ancillary_order(
	gnplaylist_rank_crit_handle_t	rank,
	gn_uint16_t						rank_ancillary_order
	);


/*	gnplaylist_rank_crit_get_ancillary_order
 *
 *  Accessor function for getting the ancillary (tiebreaker) order from an unweighted
 *	ranking criterion
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 * 		rank:				A ranking criterion either allocated or retrieved from a
 *							playlist generator.
 *		p_ancillary_order:	On success, the ancillary order for the ranking criterion
 */
gn_error_t
gnplaylist_rank_crit_get_ancillary_order(
	gnplaylist_rank_crit_handle_t	 rank,
	gn_uint16_t						*p_ancillary_order
	);


/*	MARK:	Managing Ranking Criteria
 *
 *	The functions described in this section are used for adding, retrieving, and removing the
 *	ranking criteria associated with a playlist generator.
 *
 *	Generally, an application will only need to use unweighted ranking criteria with
 *	ancillary orders. In some cases, advanced applications that are trying to achieve
 *	"more like this" functionality without using the built-in gnplaylist_morelikethis_
 *	functions may want to use weighted ranking criteria for fields that support
 *	similarity (e.g., genre, era, artist type, origin).
 *
 *	gnplaylist_plgen_addrankingcriteria
 *
 *	DEPRECATED
 *		You should now use gnplaylist_rank_crit_new_rank followed by a call to
 *		gnplaylist_plgen_add_weighted_ranking_criterion or
 *		gnplaylist_plgen_add_unweighted_ranking_criterion.
 *
 *  Adds one ranking criterion to the playlist generator.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:                A valid playlist generator.
 *      rank:               A ranking criterion, including a field, and the order (ascending/descending)
 *      ancillary_order:    Ancillary order.  Usually 0, you can set to 1 for tiebreaker
 *							(secondary rank), or even 2 for tertiary tiebreaker.
 */
gn_error_t
gnplaylist_plgen_addrankingcriteria(
	gnpl_playlist_gen_handle_t	hpl,
	gnpl_playlist_rank_t		rank,
	gn_uint16_t					ancillary_order
	);


/*	gnplaylist_plgen_add_weighted_ranking_criterion
 *
 *	Adds a weighted ranking criterion to a playlist generator. Note that on success, the
 *	generator now owns the memory for the ranking criterion, and you do not have to free it
 *	directly. Note that if a weighted ranking criterion with the same field already existed,
 *	it will be overwritten by this one.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:		A valid playlist generator.
 *		rank:		A valid ranking criterion that has been allocated and set up with the
 *					ranking criteria management functions
 */
gn_error_t
gnplaylist_plgen_add_weighted_ranking_criterion(
	gnpl_playlist_gen_handle_t		hpl,
	gnplaylist_rank_crit_handle_t	rank
	);


/*	gnplaylist_plgen_add_unweighted_ranking_criterion
 *
 *	Adds a unweighted ranking criterion to a playlist generator. Note that on success,
 *	the generator now owns the memory for the ranking criterion and you do not have to
 *	free it directly. Note that if a unweighted ranking criterion with the same field
 *	already existed, it will be overwritten by this one.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:    A valid playlist generator.
 *		rank:	A valid ranking criterion that has been allocated and set up with the
 *				ranking criteria management functions
 */
gn_error_t
gnplaylist_plgen_add_unweighted_ranking_criterion(
	gnpl_playlist_gen_handle_t		hpl,
	gnplaylist_rank_crit_handle_t	rank
	);


/*	gnplaylist_plgen_getrankingcriteria
 *
 *	DEPRECATED
 *		You should now use one of these functions:
 *			gnplaylist_plgen_get_weighted_ranking_criterion_byfield
 *			gnplaylist_plgen_get_weighted_ranking_criterion_byindex
 *			gnplaylist_plgen_get_weighted_ranking_criterion_count
 *		or:
 *			gnplaylist_plgen_get_unweighted_ranking_criterion_byfield
 *			gnplaylist_plgen_get_unweighted_ranking_criterion_byindex
 *			gnplaylist_plgen_get_unweighted_ranking_criterion_count
 *
 *	Gets one ranking criterion from the playlist generator.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:                A valid playlist generator.
 *      p_rank:             On success, the ranking criterion with the ancillary order specified.
 *      ancillary_order:    Rank order.  Usually 0, you can set to 1 for tiebreaker (secondary rank),
 *                          or even 2 for tertiary tiebreaker.
 */
gn_error_t
gnplaylist_plgen_getrankingcriteria(
	gnpl_playlist_gen_handle_t	 hpl,
	gnpl_playlist_rank_t		*p_rank,
	gn_uint16_t					 ancillary_order
	);


/*	gnplaylist_plgen_get_weighted_ranking_criterion_count
 *
 *  Gets the number of weighted ranking criteria in a playlist generator.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		hpl:    		A valid playlist generator.
 *		p_ret_count:	Reference to a gn_uint16_t.  On success, populated with the number
 *						of weighted ranking criteria.
 */
gn_error_t
gnplaylist_plgen_get_weighted_ranking_criterion_count(
	gnpl_playlist_gen_handle_t		 hpl,
	gn_uint16_t						*p_ret_count
	);


/*	gnplaylist_plgen_get_weighted_ranking_criterion_byindex
 *
 *  Gets a weighted ranking criterion from a playlist generator if one exists at that index.
 *	No memory is allocated, and the criterion is still owned by the playlist generator.
 *
 *	Return Value: GN_SUCCESS or error code.
 *	Returns GNERR_NotFound if there was no unweighted ranking criterion with that index.
 *
 *	Parameters
 *		hpl:			A valid playlist generator.
 *		index:			Index of the ranking crtierion. A number between 0 and the count of
 *						unweighted ranking criteria.
 *		p_ret_rank:		Pointer to a gnplaylist_rank_crit_handle_t.  On success, the handle
 *						will refer to the found ranking criterion.
 */
gn_error_t
gnplaylist_plgen_get_weighted_ranking_criterion_byindex(
	gnpl_playlist_gen_handle_t		 hpl,
	gn_uint16_t						 index,
	gnplaylist_rank_crit_handle_t	*p_ret_rank
	);


/*	gnplaylist_plgen_get_weighted_ranking_criterion_byfield
 *
 *  Gets a weighted ranking criterion from a playlist generator, if one exists for that field.
 *	No memory is allocated, and the criterion is still owned by the playlist generator.
 *
 *	Return Value: GN_SUCCESS or error code.
 *	Returns GNERR_NotFound if there was no weighted ranking criterion with that field.
 *
 *	Parameters
 *		hpl:		A valid playlist generator.
 *		field:		A field by which to rank.
 *		p_ret_rank:	Pointer to a gnplaylist_rank_crit_handle_t.  On success, the handle
 *					will refer to the found ranking criterion.
 */
gn_error_t
gnplaylist_plgen_get_weighted_ranking_criterion_byfield(
	gnpl_playlist_gen_handle_t		 hpl,
	gnpl_crit_field_t				 field,
	gnplaylist_rank_crit_handle_t	*p_ret_rank
	);


/*	gnplaylist_plgen_get_unweighted_ranking_criterion_count
 *
 *  Gets the number of unweighted ranking criteria in a playlist generator.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 * Parameters:
 *		hpl:    		A valid playlist generator.
 *		p_ret_count:	Reference to a gn_uint16_t.  On success, populated with the number
 *						of unweighted ranking criteria.
 */
gn_error_t
gnplaylist_plgen_get_unweighted_ranking_criterion_count(
	gnpl_playlist_gen_handle_t	 hpl,
	gn_uint16_t					*p_ret_count
	);


/*	gnplaylist_plgen_get_unweighted_ranking_criterion_byindex
 *
 *  Gets a unweighted ranking criterion from a playlist generator if one exists at that index.
 *
 *	Return Value: GN_SUCCESS or error code.  Error code may be GNERR_NotFound if there are not
 *
 *	Parameters
 *		hpl:    	A valid playlist generator.
 *		index:		Index of the ranking crtierion. A number between 0 and the count of
 *					ununweighted ranking criteria.
 *		p_ret_rank:	Pointer to a gnplaylist_rank_crit_handle_t.  On success, the handle
 *					will refer to the found ranking criterion.
 */
gn_error_t
gnplaylist_plgen_get_unweighted_ranking_criterion_byindex(
	gnpl_playlist_gen_handle_t		 hpl,
	gn_uint16_t						 index,
	gnplaylist_rank_crit_handle_t	*p_ret_rank
	);


/*	gnplaylist_plgen_get_unweighted_ranking_criterion_byfield
 *
 *  Gets a unweighted ranking criterion from a playlist generator, if one exists for that field.
 *	No memory is allocated, and the criterion is still owned by the playlist generator.
 *
 *	Return Value: GN_SUCCESS or error code.
 *	Returns GNERR_NotFound if there was no unweighted ranking criterion with that field.
 *
 * Parameters:
 *		hpl:		A valid playlist generator.
 *		field:		A field by which to rank.
 */
gn_error_t
gnplaylist_plgen_get_unweighted_ranking_criterion_byfield(
	gnpl_playlist_gen_handle_t		 hpl,
	gnpl_crit_field_t				 field,
	gnplaylist_rank_crit_handle_t	*p_ret_rank
	);


/*	gnplaylist_plgen_removerankingcriteria
 *
 *	DEPRECATED
 *		You should now use gnplaylist_plgen_remove_weighted_ranking_criterion_byfield
 *		or gnplaylist_plgen_remove_unweighted_ranking_criterion_byfield
 *
 *  Removes a ranking criterion from the playlist generator.
 *
 *	Return Value: GN_SUCCESS or error code.
 *	GNERR_NotFound if no limit had been set for the specified field.
 *
 * Parameters:
 *		hpl:                A valid playlist generator.
 *      ancillary_order:    Rank order of ranking criterion to delete.
 *                          Usually 0, you can set to 1 for tiebreaker (secondary rank),
 *                          or even 2 for tertiary tiebreaker.
 */
gn_error_t
gnplaylist_plgen_removerankingcriteria(
	gnpl_playlist_gen_handle_t	hpl,
	gn_uint16_t					ancillary_order
	);


/*	gnplaylist_plgen_remove_weighted_ranking_criterion_byfield
 *
 *  Removes a weighted ranking criterion from a playlist generator, if one exists for that field.
 *
 *	Return Value: GN_SUCCESS or error code.
 *	Returns GNERR_NotFound if there was no weighted ranking criterion with that field.
 *
 * Parameters:
 *		hpl:		A valid playlist generator.
 *		field:		A field by which to rank - any previously stored weighted ranking
 *					criteria with this field will be removed
 */
gn_error_t
gnplaylist_plgen_remove_weighted_ranking_criterion_byfield(
	gnpl_playlist_gen_handle_t		hpl,
	gnpl_crit_field_t				field
	);


/*	gnplaylist_plgen_remove_unweighted_ranking_criterion_byfield
 *
 *  Removes a unweighted ranking criterion from a playlist generator, if one exists for that field.
 *
 *	Return Value: GN_SUCCESS or error code.
 *	Returns GNERR_NotFound if there was no unweighted ranking criterion with that field.
 *
 * Parameters:
 *		hpl:		A valid playlist generator.
 *		field:		A field by which to rank - any previously stored unweighted ranking
 *					criteria with this field will be removed
 */
gn_error_t
gnplaylist_plgen_remove_unweighted_ranking_criterion_byfield(
	gnpl_playlist_gen_handle_t	hpl,
	gnpl_crit_field_t			field
	);


/*	------------------------------------------------------------------------------------------
 *	MARK:	Generating Playlists
 *
 *	This section describes the functions for generating playlists. Playlist generation can be
 *	done in either of two  ways:
 *
 *		From a predefined playlist generator;
 *		From a seed track, album, or artist, using More Like This functionality.
 *
 *	In addition, functions are available for configuring various aspects of More Like This playlist
 *	generation, such as playlist and per-field limits. 
 *
 *	The playlist generation functions return their results in the form of a Playlist results
 *	handle, an opaque pointer of type gnplaylist_results_handle_t (declared in header file
 *	gn_playlist_types.h).  This handle can then be used to access information about the
 *	individual tracks in the playlist using the accessor functions.
 */

/*	MARK:	Generating Playlists from a Generator
 *
 *
 *	gnplaylist_generateplaylist_results
 *
 *	Generates a playlist from a playlist generator.
 *	Populates the gnplaylist_results_handle_t p_results which must subsequently be freed with
 *	a call to gnplaylist_freeplaylistresults.
 *
 *	If this playlist generator requires seed tracks, they should be provided via
 *	the seed_metadata_list parameter.
 *
 *	If no results are generated, p_results will be set to GN_NULL, p_num_results will be set to
 *	0, and the error returned will be GN_SUCCESS.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		plgen:				Handle to a playlist generator created by a call
 *							to gnplaylist_plgen_create_playlistgen.
 *		seed_metadata_list:	List of entrydata for all seed tracks
 *							(required only for seed-based generators).
 *		numseeds:			Number of seeds in the seed_metadata_list.
 *		p_results:			On return, a handle to an allocated gnplaylist_results_handle_t
 *							structure, which contains information necessary to retrieve result data.
 *							This should be freed with gnplaylist_free_playlist_results
 *		p_num_results:		On return, the number of results in the returned
 *							gnplaylist_results_handle_t structure.
 */
gn_error_t
gnplaylist_generateplaylist_results(
	gnpl_playlist_gen_handle_t	 plgen,
	gnplaylist_entrydata_t		*seed_metadata_list,
	gn_uint16_t					 numseeds,
	gnplaylist_results_handle_t	*p_results,
	gn_uint32_t					*p_num_results
	);


/*	gnpl_playlist_cancel_callback_t
 *
 *	A function with this prototype is implemented by the developer to return GN_TRUE if
 *	playlist generation is to be canceled, otherwise GN_FALSE.
 *
 *	NOTE: The user callback function, if it is set, will be called often during playlist
 *	generation so it should be as lightweight and efficient as possible.
 *
 *	Parameters:
 *		user_data		Address of optional user defined data that was set in the initial
 *						call to gnplaylist_set_cancel_callback().
 */
typedef gn_bool_t (gnpl_playlist_cancel_callback_t)(void * user_data);


/*	gnplaylist_set_cancel_callback
 *
 *	Set a callback function that the Playlist Manager can call during Playlist generation
 *	to test if the user wishes to cancel the playlist.
 *
 *	Return Value:
 *		GN_SUCCESS		This function always returns GN_SUCCESS.
 *
 *	Parameters:
 *		callback_func	Address of a user defined callback function or GN_NULL to remove
 *						the callback.
 *
 *		user_data		Address of optional user defined data that will be passed to the user's
 *						callback function by the Playlist Manager when a call is made to the
 *						user's callback function. Pass GN_NULL if no data is to be provided.
 */
gn_error_t
gnplaylist_set_cancel_callback(
	gnpl_playlist_cancel_callback_t	*callback_func,
	void							*user_data
	);


/*	MARK:	Generating "More Like This" Playlists
 *
 *
 *	gnplaylist_morelikethis_songs
 *
 *	Generates a "More Like This" playlist based on one or more seed entries.
 *	Populates the gnplaylist_results_handle_t p_results which must subsequently be freed with
 *	a call to gnplaylist_freeplaylistresults.
 *
 *	If no results are generated, p_results will be set to GN_NULL, p_num_results will be set to
 *	0, and the error returned will be GN_SUCCESS.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		seed_metadata_list:	List of entrydata for all seed tracks
 *		numseeds:		Number of seeds in the seed_metadata_list.
 *		cfg:			Optional configuration structure to control the results.  Can be GN_NULL.
 *		p_results:		On return, a handle to an allocated gnplaylist_results_handle_t
 *						structure, which contains information necessary to retrieve result data.
 *						This should be freed with gnplaylist_free_playlist_results
 *		p_num_results:	On return, the number of results in the returned
 *						gnplaylist_results_handle_t structure.
 */
gn_error_t
gnplaylist_morelikethis_songs(
	gnplaylist_entrydata_t			*seed_metadata_list,
	gn_uint16_t						 numseeds,
	gnplaylist_morelikethis_cfg_t	 cfg,
	gnplaylist_results_handle_t		*p_results,
	gn_uint32_t						*p_num_results
	);


/*	gnplaylist_morelikethis_album
 *
 *	Generates a "More Like This" playlist based on an album name.
 *	Populates the gnplaylist_results_handle_t p_results which must subsequently be freed with
 *	a call to gnplaylist_freeplaylistresults.
 *
 *	The MLDB must contain at least one entry with this album name that has Gracenote extended data.
 *
 *	If no results are generated, p_results will be set to GN_NULL, p_num_results will be set to
 *	0, and the error returned will be GN_SUCCESS.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		album:			The Album name to search for.
 *		artist:			Optional: The artist of the Album (in case the Album name is not unique).
 *						Can be GN_NULL.
 *		cfg:			Optional configuration structure to control the results.
 *						Can be GN_NULL.
 *		p_results:		On return, a handle to an allocated gnplaylist_results_handle_t
 *						structure, which contains information necessary to retrieve result data.
 *						This should be freed with gnplaylist_free_playlist_results
 *		p_num_results:	On return, the number of results in the returned
 *						gnplaylist_results_handle_t structure.
 */
gn_error_t
gnplaylist_morelikethis_album(
	const gn_uchar_t				*album,
	const gn_uchar_t				*artist,
	gnplaylist_morelikethis_cfg_t	 cfg,
	gnplaylist_results_handle_t		*p_results,
	gn_uint32_t						*p_num_results
	);


/*	gnplaylist_morelikethis_artist
 *
 *	Generates a "More Like This" playlist based on an artist name.
 *	Populates the gnplaylist_results_handle_t p_results which must subsequently be freed with
 *	a call to gnplaylist_freeplaylistresults.
 *
 *	The MLDB must contain at least one entry with this artist name that has Gracenote extended data.
 *
 *	If no results are generated, p_results will be set to GN_NULL, p_num_results will be set to
 *	0, and the error returned will be GN_SUCCESS.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		artist:			The Artist name to search for.
 *		cfg:			Optional configuration structure to control the results.  Can be GN_NULL.
 *		p_results:		On return, a handle to an allocated gnplaylist_results_handle_t
 *						structure, which contains information necessary to retrieve result data.
 *						This should be freed with gnplaylist_free_playlist_results
 *		p_num_results:	On return, the number of results in the returned
 *						gnplaylist_results_handle_t structure.
 */
gn_error_t
gnplaylist_morelikethis_artist(
	const gn_uchar_t				*artist,
	gnplaylist_morelikethis_cfg_t	 cfg,
	gnplaylist_results_handle_t		*p_results,
	gn_uint32_t						*p_num_results
	);


/*	The following three API are esentially the same as their counterparts described above
 *	except instead of locating the seed by track, album, or artist name, the corresponding
 *	ID is used.  The IDs were introduced with the Release 5.4 MLDB and can be obtained from an
 *	entrydata record by their field accessors:
 *
 *		gnpl_crit_field_track_id
 *		gnpl_crit_field_album_id
 *		gnpl_crit_field_artist_id
 */

/*	gnplaylist_morelikethis_track_id
 *
 *	Generates a "More Like This" playlist based on a seed track identified by track_id.
 *	The seed track must exist in at least one of the currently enabled MLDBs.
 *
 *	Memory is allocated for p_results upon successful return which the developer is
 *	expected to free by calling gnplaylist_freeplaylistresults.
 *
 *	If no results are generated, p_results will be set to GN_NULL, p_num_results will be set to
 *	0, and the error returned will be GN_SUCCESS.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *		PLMERR_InvalidArg
 *			Either p_results or p_num_results is null.
 *
 *		PLMERR_CollectionNotOpened
 *			There are no open MLDBs.
 *
 *		PLMERR_NotFound
 *			The seed track was not found.
 *
 *		PLMERR_NoMemory
 *			Not enough memory available to allocate the playlist results.
 *
 *	Parameters:
 *		track_id:
 *			The seed track ID
 *
 *		cfg:
 *			Optional configuration structure to control the results.  Can be GN_NULL.
 *
 *		p_results:
 *			On return, a handle to an allocated gnplaylist_results_handle_t
 *			structure, which contains information necessary to retrieve result data.
 *
 *		p_num_results
 *			On return, the number of results in the returned gnplaylist_results_handle_t
 *			structure.
 */
gn_error_t
gnplaylist_morelikethis_track_id(
	gn_uint32_t						 track_id,
	gnplaylist_morelikethis_cfg_t	 cfg,
	gnplaylist_results_handle_t		*p_results,
	gn_uint32_t						*p_num_results
	);

/*	gnplaylist_morelikethis_album_id
 *
 *	Generates a "More Like This" playlist based on a seed album identified by album_id.
 *	The seed album must exist in at least one of the currently enabled MLDBs.
 *
 *	Memory is allocated for p_results upon successful return which the developer is
 *	expected to free by calling gnplaylist_freeplaylistresults.
 *
 *	If no results are generated, p_results will be set to GN_NULL, p_num_results will be set to
 *	0, and the error returned will be GN_SUCCESS.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *		PLMERR_InvalidArg
 *			Either p_results or p_num_results is null.
 *
 *		PLMERR_CollectionNotOpened
 *			There are no open MLDBs.
 *
 *		PLMERR_NotFound
 *			The seed album was not found.
 *
 *		PLMERR_NoMemory
 *			Not enough memory available to allocate the playlist results.
 *
 *	Parameters:
 *		album_id:
 *			The seed album ID
 *
 *		cfg:
 *			Optional configuration structure to control the results.  Can be GN_NULL.
 *
 *		p_results:
 *			On return, a handle to an allocated gnplaylist_results_handle_t
 *			structure, which contains information necessary to retrieve result data.
 *
 *		p_num_results
 *			On return, the number of results in the returned gnplaylist_results_handle_t
 *			structure.
 */
gn_error_t
gnplaylist_morelikethis_album_id(
	gn_uint32_t						 album_id,
	gnplaylist_morelikethis_cfg_t	 cfg,
	gnplaylist_results_handle_t		*p_results,
	gn_uint32_t						*p_num_results
	);


/*	gnplaylist_morelikethis_artist_id
 *
 *	Generates a "More Like This" playlist based on a seed artist identified by artist_id.
 *	The seed artist must exist in at least one of the currently enabled MLDBs.
 *
 *	Memory is allocated for p_results upon successful return which the developer is
 *	expected to free by calling gnplaylist_freeplaylistresults.
 *
 *	If no results are generated, p_results will be set to GN_NULL, p_num_results will be set to
 *	0, and the error returned will be GN_SUCCESS.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *		PLMERR_InvalidArg
 *			Either p_results or p_num_results is null.
 *
 *		PLMERR_CollectionNotOpened
 *			There are no open MLDBs.
 *
 *		PLMERR_NotFound
 *			The seed artist was not found.
 *
 *		PLMERR_NoMemory
 *			Not enough memory available to allocate the playlist results.
 *
 *	Parameters:
 *		artist_id:
 *			The seed artist ID
 *
 *		cfg:
 *			Optional configuration structure to control the results.  Can be GN_NULL.
 *
 *		p_results:
 *			On return, a handle to an allocated gnplaylist_results_handle_t
 *			structure, which contains information necessary to retrieve result data.
 *
 *		p_num_results
 *			On return, the number of results in the returned gnplaylist_results_handle_t
 *			structure.
 */
gn_error_t
gnplaylist_morelikethis_artist_id(
	gn_uint32_t						 artist_id,
	gnplaylist_morelikethis_cfg_t	 cfg,
	gnplaylist_results_handle_t		*p_results,
	gn_uint32_t						*p_num_results
	);


/*	gnplaylist_morelikethis_ext_data
 *
 *	Generates a "More Like This" playlist based on extended data.
 *
 *	Populates the gnplaylist_results_handle_t p_results which must subsequently be freed with
 *	a call to gnplaylist_freeplaylistresults.
 *
 *	If no results are generated, p_results will be set to GN_NULL, p_num_results will be set to
 *	0, and the error returned will be GN_SUCCESS.
 *
 *	Extended data can represent an album or a track.  For an album the data is obtained from a
 *	gn_palbum_t structure with a call to gn_album_data_get_album_ext_data().  For a track the data
 *	is obtained by calling gn_ext_data_merge() on the album extended data and the results of a call
 *	to gn_album_data_get_track_ext_data() for a specific track on that album.
 *
 *	Extended data may also be obtained by a call to gn_ext_data_deserialize() on data that had been
 *	previously serialized to external storage.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	PLMERR_InvalidArg
 *							One or more arguments were invalid.
 *	PLMERR_UnsupportedFunctionality
 *							Playlist is not supported or is not initialized.
 *	PLMERR_NoMemory
 *							Not enough memory to complete this operation.
 *
 *	Parameters:
 *		pext_data:			Structure containing extended data
 *		cfg:				Optional configuration structure to control the results.  Can be GN_NULL.
 *		p_results:			On return, a handle to an allocated gnplaylist_results_handle_t
 *							structure, which contains information necessary to retrieve result data.
 *							This should be freed with gnplaylist_free_playlist_results
 *		p_num_results:		On return, the number of results in the returned
 *							gnplaylist_results_handle_t structure.
 */
gn_error_t
gnplaylist_morelikethis_ext_data(
	gn_pext_data_t					 pext_data,
	gnplaylist_morelikethis_cfg_t	 cfg,
	gnplaylist_results_handle_t		*p_results,
	gn_uint32_t						*p_num_results
	);


/*	gnplaylist_morefromfield
 *
 *	Generates a playlist using a specified field in a set of one or more seed songs.
 *	This function populates a gnpl_results_handle_t data structure. Your application must
 *	subsequently free p_results with gnplaylist_freeplaylistresults.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		field:				The field for which results should have matching value to the seeds.
 *							Common fields are album, artist, year, era
 *		seed_metadata_list	List of entrydata for all seed tracks.
 *		numseeds:			Number of seeds in the seed_metadata_list.
 *		cfg:				Optional configuration structure to control the results.
 *							Can be GN_NULL.
 *		p_results:			On return, a handle to an allocated gnplaylist_results_handle_t
 *							structure. See gnplaylist_get_results_data for obtaining detailed
 *							result information from this handle.
 *		p_num_results:		On return, the number of results in the returned
 *							gnplaylist_results_handle_t structure.
 */
gn_error_t
gnplaylist_morefromfield(
	gnpl_crit_field_t				 field,
	gnplaylist_entrydata_t			*seed_metadata_list,
	gn_uint16_t						 numseeds,
	gnplaylist_morelikethis_cfg_t	 cfg,
	gnplaylist_results_handle_t		*p_results,
	gn_uint32_t						*p_num_results
	);


/*	gnplaylist_morelikethis_cfg_new_cfg
 *
 *	Creates and initializes a new More Like This configuration structure that you can modify and
 *	use in any of the gnplaylist_morelikethis functions.  The function will initialize the
 *	configuration structure and populate it with default values.  You should later free the
 *	configuration structure using gnplaylist_morelikethis_cfg_free_cfg.
 *
 *	The default configuration values are set as follows:
 *
 *		max_tracks			no more than 30 tracks in the playlist
 *		max_per_album		no more than 4 tracks from any one album
 *		max_per_artist		no more than 4 tracks by any one artist
 *		max_kb_size			no limit on the total file sizes of all tracks in the playlist
 *		max_mins_length		no limit on the total play time for all tracks in the playlist
 *		random				randomize the playlist tracks
 *		selection_type		GNPL_CRITERION_IS_SELECTION_BASED
 *		exclude_list		no track exclusion list
 *
 *	These default values may be overridden by calling one or more of the set functions:
 *
 *		gnplaylist_morelikethis_cfg_set_tracklimit
 *		gnplaylist_morelikethis_cfg_set_max_per_album
 *		gnplaylist_morelikethis_cfg_set_max_per_artist
 *		gnplaylist_morelikethis_cfg_set_max_kblimit
 *		gnplaylist_morelikethis_cfg_set_max_minslimit
 *		gnplaylist_morelikethis_cfg_set_random
 *		gnplaylist_morelikethis_cfg_set_selection_type
 *		gnplaylist_morelikethis_cfg_set_exclude_list
 *
 *	Return Value:
 *		GN_SUCCESS			The new config structure has been allocated
 *		PLMERR_InvalidArg	The caller specified a null config structure pointer
 *		PLMERR_NoMemory		The system is out of memory
 *
 *	Parameters
 *		p_config:			Pointer to a gnplaylist_morelikethis_cfg_t handle.
 *							On return, will be populated with a valid,
 *							initialized gnplaylist_morelikethis_cfg_t.
 */
gn_error_t gnplaylist_morelikethis_cfg_new_cfg(
	gnplaylist_morelikethis_cfg_t	*p_config
	);


/*	gnplaylist_morelikethis_cfg_set_algorithm
 *
 *	Sets the algorithm for a gnplaylist_morelikethis_cfg_t struct.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		cfg:			An allocated gnplaylist_morelikethis_cfg_t handle.
 *
 *		algorithm:		Algorithm to use.
 *		Possible values are defined in gn_playlist_enums.h:
 *		GNPL_MORELIKETHIS_ALG_DEFAULT	: (Recommended) The latest Playlist More Like This Algorithm
 *		GNPL_MORELIKETHIS_ALG_20		: The old Playlist 2.0 More Like This (Intellimix) Algorithm
 *		GNPL_MORELIKETHIS_ALG_25 		: The Playlist 2.5 More Like This Algorithm
 *										  (same as GNPL_MORELIKETHIS_ALG_DEFAULT)
 */
gn_error_t gnplaylist_morelikethis_cfg_set_algorithm(
	gnplaylist_morelikethis_cfg_t	cfg,
	gnpl_morelikethis_algorithm_t	algorithm
	);


/*	gnplaylist_morelikethis_cfg_set_flags
 *
 *	Sets the flags in the More Like This configuration structure.  This function is currently not
 *	used and will have no effect on playlist generation.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		cfg:			An allocated gnplaylist_morelikethis_cfg_t handle.
 *
 *		flags:			New flags.  Currently not used.
 */
gn_error_t gnplaylist_morelikethis_cfg_set_flags(
	gnplaylist_morelikethis_cfg_t	cfg,
	gn_int32_t						flags
	);


/*	gnplaylist_morelikethis_cfg_set_tracklimit
 *
 *	Sets the maximum track limit in a More Like This configuration structure.  A value of 0 implies
 *	that no limit should be placed on the number of tracks returned in the playlist.  The default
 *	track limit for More Like This is 30.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		cfg:			An allocated gnplaylist_morelikethis_cfg_t handle.
 *
 *		max_tracks:		New track limit.  The maximum number of tracks to be returned by the
 *						morelikethis functions.  A value of 0 means no limit.
 */
gn_error_t gnplaylist_morelikethis_cfg_set_tracklimit(
	gnplaylist_morelikethis_cfg_t	cfg,
	gn_uint32_t						max_tracks
	);


/*	gnplaylist_morelikethis_cfg_set_max_per_album
 *
 *	Sets the maximum per-album limit in a More Like This configuration structure.  A value of 0
 *	implies that no limit should be placed on the number of tracks selected from the same album.
 *	The default per-album limit is 4.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		cfg:			An allocated gnplaylist_morelikethis_cfg_t handle.
 *
 *		max_per_album:	New per-album limit.  The maximum number of tracks to be returned per
 *						the same album by the morelikethis functions. A value of 0 means no limit.
 */
gn_error_t gnplaylist_morelikethis_cfg_set_max_per_album(
	gnplaylist_morelikethis_cfg_t	cfg,
	gn_uint32_t						max_per_album
	);


/*	gnplaylist_morelikethis_cfg_set_max_per_artist
 *
 *	Sets the maximum per-artist limit in a More Like This configuration structure.  A value of 0
 *	implies that no limit should be placed on the number of tracks selected by the same artist.
 *	The default per-artist limit is 4.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		cfg:			An allocated gnplaylist_morelikethis_cfg_t handle.
 *
 *		max_per_artist:	New per-artist limit.  The maximum number of tracks to be returned per
 *						the same artist by the morelikethis functions. A value of 0 means no limit.
 */
gn_error_t gnplaylist_morelikethis_cfg_set_max_per_artist(
	gnplaylist_morelikethis_cfg_t	cfg,
	gn_uint32_t						max_per_artist
	);


/*	gnplaylist_morelikethis_cfg_set_max_kblimit
 *
 *	Set a limit on the total size of all songs selected for the More Like This playlist.
 *	The size limit is in kilobytes.  The default value set when the configuration
 *	structure is created is 0, meaning no limit.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		cfg:			An allocated gnplaylist_morelikethis_cfg_t handle.
 *
 *		max_kblimit:	The maximum total kb size of all the tracks in the playlist.
 *						A value of 0 means no limit.
 */
gn_error_t gnplaylist_morelikethis_cfg_set_max_kblimit(
	gnplaylist_morelikethis_cfg_t	cfg,
	gn_uint32_t						max_kblimit
	);


/*	gnplaylist_morelikethis_cfg_set_max_minslimit
 *
 *	Set a limit on the total playing time of all songs selected for the More Like This playlist.
 *	The limit is in minutes.  The default value set when the configuration structure is
 *	created is 0, meaning no limit.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		cfg:			An allocated gnplaylist_morelikethis_cfg_t handle.
 *
 *		max_minslimit:	The maximum play time in minutes of all the tracks in the playlist.
 *						A value of 0 means no limit.
 */
gn_error_t gnplaylist_morelikethis_cfg_set_max_minslimit(
	gnplaylist_morelikethis_cfg_t	cfg,
	gn_uint32_t						max_minslimit
	);


/*	gnplaylist_morelikethis_cfg_set_random
 *
 *	Sets the randomization flag in the More Like This configuration structure, specifying whether
 *	to randomize the generated playlist (GN_TRUE) or generate a consistent playlist for the given
 *	criterion (GN_FALSE).
 *
 *	Returns PLMERR_InvalidArg if the cfg handle is null, otherwise GN_SUCCESS.
 *
 *	Parameters
 *		cfg:		An allocated gnplaylist_morelikethis_cfg_t handle.
 *		random:		GN_TRUE  - randomize the generated playlist or
 *					GN_FALSE - generate a consistant playlist for the given criteria.
 *
 *	Playlist results are randomized by default.  The only good reason why you would ever
 *	want to turn randomization off is during system testing.  In general, do not use this call.
 */
gn_error_t
gnplaylist_morelikethis_cfg_set_random(
	gnplaylist_morelikethis_cfg_t	cfg,
	gn_bool_t						random
	);


/*	gnplaylist_morelikethis_cfg_get_random
 *	Returns the value of the morelikethis randomization flag.
 *
 *	Returns PLMERR_InvalidArg if either the cfg handle or address of the random flag is null,
 *	otherwise GN_SUCCESS.
 *
 *	Parameters
 *		cfg:		An allocated gnplaylist_morelikethis_cfg_t handle.
 *		random:		address of a gn_bool_t variable that will recieve the randomization flag value.
 */
gn_error_t
gnplaylist_morelikethis_cfg_get_random(
	gnplaylist_morelikethis_cfg_t	 cfg,
	gn_bool_t						*random
	);


/*	gnplaylist_morelikethis_cfg_set_selection_type
 *
 *	Set the seed selection type.  The morelikethis algorithm is based on one or more seed songs.
 *	The seed may or may not be included in the result set depending on randomization and song count
 *	limits.  You may change this behavior by telling morelikethis to explicitly include or exclude
 *	the seed from the result set.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_InvalidArg	cfg is not a valid configuration struct or
 *							selection_type is not a valid selection type.
 *
 *	Parameters
 *		cfg:				An allocated gnplaylist_morelikethis_cfg_t handle.
 *
 *		selection_type:		One of the following selection type options:
 *
 *							GNPL_CRITERION_IS_SELECTION_BASED
 *								The seed songs may or may not be included in the result set
 *								depending on randomization and song count limits.  This is the
 *								default for morelikethis.
 *
 *							GNPL_CRITERION_INCLUDE_SEED_SELECTION
 *								The seed songs will always be included in the result set.
 *
 *							GNPL_CRITERION_TOP_SEED_SELECTION
 *								The seed songs will always be included as the first songs in the
 *								result set.
 *
 *							GNPL_CRITERION_EXCLUDE_SEED_SELECTION
 *								The seed songs will not be included in the result set.
 *
 *	Note that GNPL_CRITERION_NOT_SELECTION_BASED is not a valid morelikethis selection type.
 */
gn_error_t
gnplaylist_morelikethis_cfg_set_selection_type(
	gnplaylist_morelikethis_cfg_t	cfg,
	gnpl_crit_selection_t			selection_type
	);


/*	gnplaylist_morelikethis_cfg_get_selection_type
 *
 *	Returns the current value for the morelikethis seed selection type.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_InvalidArg	cfg is not a valid configuration struct or
 *							selection_type is a null pointer.
 *
 *	Parameters
 *		cfg:				An allocated gnplaylist_morelikethis_cfg_t handle.
 *
 *		selection_type:		An address of a gnpl_crit_selection_t variable that will be set to
 *							GNPL_CRITERION_IS_SELECTION_BASED, GNPL_CRITERION_INCLUDE_SEED_SELECTION,
 *							GNPL_CRITERION_TOP_SEED_SELECTION, or GNPL_CRITERION_EXCLUDE_SEED_SELECTION.
 */
gn_error_t
gnplaylist_morelikethis_cfg_get_selection_type(
	gnplaylist_morelikethis_cfg_t	 cfg,
	gnpl_crit_selection_t			*selection_type
	);


/*	gnplaylist_morelikethis_cfg_set_exclude_list
 *
 *	Add a list of entrydata records to the More Like This configuration structure.  These track
 *	entries will be excluded from the playlist results.
 *
 *	Pass exclude_list as GN_NULL or exclude_num as 0 to remove the excluded list from a
 *	configuration structure.
 *
 *	Memory is allocated in the configuration structure to copy the exclude_list.
 *
 *	Parameters
 *		cfg:				An allocated gnplaylist_morelikethis_cfg_t handle.
 *
 *		exclude_list:		An array of gnplaylist_entrydata_t pointers.  These track entries will
 *							be excluded from the playlist.  Pass null to clear existing list.
 *
 *		exclude_num:		The number of gnplaylist_entrydata_t records in the exclude_list.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_InvalidArg	cfg is not a valid configuration struct.
 *
 *		PLMERR_NoMemory		Not enough memory is available to allocate storage for the list.
 */
gn_error_t
gnplaylist_morelikethis_cfg_set_exclude_list(
	gnplaylist_morelikethis_cfg_t	 cfg,
	gnplaylist_entrydata_t			*exclude_list,
	gn_uint16_t						 exclude_num
	);


/*	gnplaylist_morelikethis_cfg_get_exclude_list
 *
 *	Return a copy of the exclude_list, if any, from the More Like This configuration
 *	structure.  If the configuration does not have an exclude_list the function will return
 *	GN_SUCCESS with exclude_num set to 0 and exclude_list set to GN_NULL.
 *
 *	Memory is allocated for the returned list and the developer is responsible for freeing the
 *	entries using gnplaylist_plgen_free_exclude_list.
 *
 *	Parameters
 *		cfg:				An allocated gnplaylist_morelikethis_cfg_t handle.
 *
 *		exclude_list:		Address of an gnplaylist_entrydata_t* array to recieve the list.
 *
 *		exclude_num:		Address of an gn_uint16_t to recieve the number of entries in the
 *							exclude_list.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_InvalidArg	Either cfg is not a valid configuration struct or exclude_list or
 *							exclude_num are null.
 *
 *		PLMERR_NoMemory		Not enough memory is available to allocate storage for the list.
 */
gn_error_t
gnplaylist_morelikethis_cfg_get_exclude_list(
	gnplaylist_morelikethis_cfg_t	  cfg,
	gnplaylist_entrydata_t			**exclude_list,
	gn_uint16_t						 *exclude_num
	);


/*	gnplaylist_morelikethis_cfg_free_cfg
 *
 *	Frees all memory associated with a gnplaylist_morelikethis_cfg_t handle that was previously
 *	allocated using gnplaylist_morelikethis_cfg_new_cfg
 *
 *	Return Value:
 *		GN_SUCCESS			No error.
 *		PLMERR_InvalidArg	The cfg handle address refers to a null cfg structure.
 *
 *	Parameters
 *		p_config:			Pointer to an allocated gnplaylist_morelikethis_cfg_t handle.
 *							On return, will be set to GN_NULL.
 */
gn_error_t gnplaylist_morelikethis_cfg_free_cfg(
	gnplaylist_morelikethis_cfg_t	*p_config
	);



/*	------------------------------------------------------------------------------------------
 *	MARK:	Managing Playlist Generation Results
 *
 *	The functions in this section manage the playlist results returned by the playlist generation
 *	functions described above.
 */

/*	gn_set_playlist_results
 *
 *	Set the playlist results.
 *
 *	Sets the global results handle. The gn_set_playlist_results function will automatically
 *	free the current global results handle, prior to setting a new value. Passing a GN_NULL
 *	value for the results parameter will cause gn_set_playlist_results to clean up the current
 *	global results handle without setting a new value.
 */
gn_error_t gn_set_playlist_results( gnplaylist_results_handle_t results );


/*	gn_get_playlist_results
 *
 *	Return a pointer to the playlist results.
 *
 *	Retrieves a pointer to the global results handle. To populate this handle, use
 *	gn_set_playlist_results. Do not attempt to free the results handle that is returned
 *	via gn_get_playlist_results, since the library will do so at shutdown, or during a
 *	subsequent call to gn_set_playlist_results.
 */
gnplaylist_results_handle_t gn_get_playlist_results( void );


/*	gnplaylist_get_results_count
 *
 *	Returns the number of results in a results handle.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		results:			A results handle
 *		p_num_results:		On return, the number of results in the results handle
 */
gn_error_t
gnplaylist_get_results_count(
	gnplaylist_results_handle_t	 results,
	gn_uint32_t					*p_num_results
	);


/*	gnplaylist_get_result_collection_id
 *
 *	Get the collection_id from an indexed entry in a result set.
 *
 *	The result set from a more like this or other playlist generation can include entrydata
 *	from various MLDB collections.  This function will return the collection_id for a given
 *	entry in the set.
 *
 *	Return Value: GN_SUCCESS or error code:
 *		PLMERR_InvalidArg	Bad results handle or invalid result_index.
 *
 *	Parameters:
 *		results:			Results handle that was returned from a playlist generation request.
 *		result_index:		The 0-based index of a specific result entry.
 *		cid					On return, the collection_id for the result.
 */
gn_error_t
gnplaylist_get_result_collection_id(
	gnplaylist_results_handle_t	 results,
	gn_uint32_t					 result_index,
	gn_collection_id_t			*cid
	);


/*	gnplaylist_get_result_entrydata
 *
 *	In case your application needs more information about a result than is provided by
 *	gnplaylist_get_results_data, gnplaylist_get_result_entrydata returns an allocated and
 *	populated entrydata handle for one result from the results returned by a playlist generation
 *	request.  To free the entrydata, call gnplaylist_freeentry.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters:
 *		results:			Results handle that was returned from a playlist generation request.
 *		result_index:		The 0-based index of the result that you want to retrieve entrydata for.
 *		p_ret_entrydata,	On return, the entrydata for the result.  Memory is allocated.
 */
gn_error_t
gnplaylist_get_result_entrydata(
	gnplaylist_results_handle_t	 results,
	gn_uint32_t					 result_index,
	gnplaylist_entrydata_t		*p_ret_entrydata
	);


/*	gnplaylist_get_results_data
 *
 *	Gets the results data for a range of results returned by a playlist generation request.
 *
 *	The function allocates and populates the gnpl_results_t structure, which consists of an array
 *	of gnpl_results_t structures and the count of elements in the array. To free the results data,
 *	call gnplaylist_freeresults.
 *
 *	In all cases the function populates a minimum set of the gnpl_results_t fields for the
 *	result: filename, title, length_secs, size_bytes, tag_id, tui_id, and collection_id.
 *	You can also set the data_selection_mask to be any combination of mask bits.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		results:			Results handle that was returned from a playlist generation request.
 *		range_low:			The first result to populate and return.  0 indexed.
 *		range_high:			The last result to populate and return. 0 indexed.
 *							If both range_low and range_high are the same, only one result will be returned.
 *		p_populated_results:	On return, gnpl_results_t structure that holds an array of populated
 *							results (gnpl_result_t), and the number of results.
 *							Memory is allocated for this structure, and for all returned results.
 *
 *	data_selection_mask:
 *		A mask to specify which fields in the gnpl_results_t structure to populate.
 *		The default is GNPL_RESULTS_DATA_MINIMUM but you may use any combination
 *		of the following mask bits:
 *
 *		GNPL_RESULTS_DATA_MINIMUM		- the minimum set of data that's required for a result:
 *										  filename, title, file length, file size, tag_id, tui_id,
 *										  and collection_id.
 *		GNPL_RESULTS_DATA_FILEPATH		- the filepath of the gnpl_result_t will be populated
 *		GNPL_RESULTS_DATA_ARTIST		- the artist field of the gnpl_result_t will be populated
 *		GNPL_RESULTS_DATA_ALBUM			- the album field of the gnpl_result_t will be populated
 *		GNPL_RESULTS_DATA_USER_RATING	- the user rating field of the gnpl_result_t will be populated
 *		GNPL_RESULTS_DATA_BITRATE		- the bitrate field of the gnpl_result_t will be populated
 *		GNPL_RESULTS_DATA_RELEASEYEAR	- the original release year of the track
 *		GNPL_RESULTS_DATA_LASTPLAYED	- the most recent date gnpl_crit_field_track_playcount was incremented
 *		GNPL_RESULTS_DATA_DEVFIELD1		- the first developer field
 *		GNPL_RESULTS_DATA_ALL			- all possibile fields of the gnpl_result_t will be populated
 */
gn_error_t
gnplaylist_get_results_data(
	gnplaylist_results_handle_t			  results,
	gnpl_results_t						**p_populated_results,
	gn_uint32_t							  range_low,
	gn_uint32_t							  range_high,
	gnpl_results_data_mask_flags_enum	  data_selection_mask
	);


/*	gnplaylist_freeresults
 *
 *	Frees memory for a gnpl_results_t pointer and all gnpl_result_t structures pointed to within
 *	the gnpl_results_t.  Call this function to free the results returned from
 *	gnplaylist_get_results_data.  The plresults pointer value will be set to GN_NULL after
 *	memory is successfully freed.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		plresults:			Handle to results that need to be freed.
 */
gn_error_t
gnplaylist_freeresults(
	gnpl_results_t		**plresults
	);


/*	gnplaylist_freeplaylistresults
 *
 *	Frees memory for a playlists results handle.  Call this function to free the results
 *	returned from gnplaylist_generateplaylist_results.  The p_results pointer value will be set
 *	to GN_NULL after memory is successfully freed.
 *
 *	Note, if you have any gnpl_results_t structures that were obtained from the
 *	gnplaylist_results_handle_t, they will NOT be freed by this call.  You must separately
 *	call gnplaylist_freeresults for any gnpl_results_t structures you have.
 *
 *	Return Value: GN_SUCCESS or error code.
 *
 *	Parameters
 *		plresults:	Handle to results that need to be freed. Will be set to GN_NULL on success.
 */
gn_error_t
gnplaylist_freeplaylistresults(
	gnplaylist_results_handle_t	*p_results
	);


/*	------------------------------------------------------------------------------------------
 *	Utility Functions implemented in gn_playlist_filedb.c that are useful for implementing
 *	playlist generator GUI applications.
 */

/*	Return a description for this field.  Some examples are:
 *		"Filename"				gnpl_crit_field_file_name
 *		"File size"				gnpl_crit_field_file_size
 *		"Last Played date"		gnpl_crit_field_file_lastplayed_date
 *		"Genre"					gnpl_crit_field_track_genrev2
 *
 *	Returns GN_NULL if field is not recognised.
 *
 *	The pointer returned by this function is owned internally and should not be freed
 *	by the developer.
 */
const gn_uchar_t*
gnpl_get_crit_field_desc(
	gnpl_crit_field_t	field
	);


/*	Return the field type descriptor for this field.  Some examples are:
 *		gnpl_crit_field_type_string		gnpl_crit_field_file_name
 *		gnpl_crit_field_type_num		gnpl_crit_field_file_size
 *		gnpl_crit_field_type_date		gnpl_crit_field_file_lastplayed_date
 *		gnpl_crit_field_type_enum		gnpl_crit_field_track_genrev2
 *
 *	Returns gnpl_crit_field_type_unknown if field is not recognised.
 */
gnpl_crit_field_type_t
gnpl_get_crit_field_type(
	gnpl_crit_field_t	field
	);


/*	Return a unit description for certain fields.  This is valid for just these four fields:
 *		"kb"				gnpl_crit_field_file_size
 *		"seconds"			gnpl_crit_field_file_length
 *		"kbps"				gnpl_crit_field_file_bitrate
 *		"bpm"				gnpl_crit_field_track_bpm
 *
 *	Returns GN_NULL if field is not recognised.
 *
 *	The pointer returned by this function is owned internally and should not be freed
 *	by the developer.
 */
const gn_uchar_t*
gnpl_get_crit_field_units(
	gnpl_crit_field_t	field
	);


/*	Returns an operator description.  Some examples are:
 *		"is equal to"		gnpl_crit_op_str_eq
 *		"contains"			gnpl_crit_op_str_cont
 *		"is greater than"	gnpl_crit_op_num_gt
 *		"is in the last"	gnpl_crit_op_date_inlast
 *
 *	Returns GN_NULL if op is not recognised as a valid field operator.
 *
 *	The pointer returned by this function is owned internally and should not be freed
 *	by the developer.
 */
const gn_uchar_t*
gnpl_get_crit_op_desc(
	gnpl_crit_op_t		op
	);


/*	Returns a unit description for two specific date operators:
 *		"days"				gnpl_crit_op_date_inlast
 *		"days"				gnpl_crit_op_date_notinlast
 *
 *	Returns GN_NULL if op is neither one of gnpl_crit_op_date_inlast or gnpl_crit_op_date_notinlast.
 *
 *	The pointer returned by this function is owned internally and should not be freed
 *	by the developer.
 */
const gn_uchar_t*
gnpl_get_crit_op_units(
	gnpl_crit_op_t		op
	);


/*	Returns a user rating description for a given gnpl_user_info_t type.
 *		"Highest"					gnpl_user_rating_highest
 *		"Favorite"					gnpl_user_rating_favorite
 *		"Lowest"					gnpl_user_rating_lowest
 *		"Good"						gnpl_user_rating_good
 *		"Never Played"				gnpl_user_play_never
 *		"Recently Played"			gnpl_user_play_recent
 *		"Played Within 30 Days"		gnpl_user_play_last_30_days
 *		"Played Within Last Week"	gnpl_user_play_last_week
 *		"Played Within Last Day"	gnpl_user_play_last_day
 *
 *	Returns GN_NULL if info is not recognised as a valid gnpl_user_info_t.
 *
 *	The pointer returned by this function is owned internally and should not be freed
 *	by the developer.
 */
const gn_uchar_t*
gnpl_get_user_info_desc(
	gnpl_user_info_t	info
	);


/*	Returns a description based on the field and rank order, for example:
 *
 *		"Date Played, Most Recent"	for gnpl_crit_field_file_lastplayed_date, gnpl_rank_order_ascending
 *		"Date Played, Not Recently"	for gnpl_crit_field_file_lastplayed_date, gnpl_rank_order_descending
 *
 *	Returns GN_NULL if the field is not a valid ranked field.
 *
 *	Fields that correspond with a ranking order are:
 *		gnpl_crit_field_file_lastplayed_date
 *		gnpl_crit_field_file_bitrate
 *		gnpl_crit_field_track_playcount
 *		gnpl_crit_field_track_myrating
 *
 *	The pointer returned by this function is owned internally and should not be freed
 *	by the developer.
 */
const gn_uchar_t*
gnpl_get_cutoff_field_desc(
	gnpl_crit_field_t	field,
	gnpl_rank_order_t	order
	);

/* END: UTILITY FUNCTIONS */

#ifdef __cplusplus
}
#endif
#endif /* _GN_PLAYLIST_H_ */
