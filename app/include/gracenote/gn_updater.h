/*
 * Copyright (c) 2007 Gracenote.
 *
 * This software may not be used in any way or distributed without
 * permission. All rights reserved.
 *
 * Some code herein may be covered by US and international patents.
 */

/*
 * gn_updater.h - Local database incremental update interface. This interface
 *                is used to apply updates to the local database files which
 *                are distributed with the library. This set of files varies
 *                depending on the product configuration, but may include files
 *                such as
 *                  the CD TOC database
 *                  the lists database
 *                  the genre correlation tables
 *                  the contributor and genre lookup tables for playlist plus
 *                  the phonetic transcription data for MediaVOCs
 *                  the preset playlist generator
 *
 *                There are other files, generated by the user, which are not
 *                modified via the updater interface. Again, these files depend
 *                on the project configuration, but may include files such as
 *                  the local CD cache file
 *                  the lookup cache file
 *                  the user playlist generator file
 *                  the metadata local database used with playlist
 *
 *                Refer to the Implementation Guide for a complete listing of
 *                eMMS database files used by your product configuration.
 */

#ifndef	_GN_UPDATER_H_
#define _GN_UPDATER_H_

#include "gn_defines.h"
#include "gn_build.h"
#include "gn_validate.h"

#ifdef __cplusplus
extern "C"{
#endif 

/**
 ** constants
 **/

/* GN_VALIDATE_OPS_UPD_OPS: Indicates what validation steps will be done before
 *                        starting the database upate process, i.e. at the
 *                        beginning of gn_update_apply_update(). You can
 *                        override this via the upd_validation_ops member of a
 *                        gninit_configuration_t structure.
 */
#define GN_VALIDATE_OPS_UPD_OPS (GN_VALIDATE_OPS_HEADERS | \
                                 GN_VALIDATE_OPS_UPD_CRC | \
                                 GN_VALIDATE_OPS_UPD_SPOT)

/* update state identifier for update status callback
 *
 * UPDSTATE_Default        Update not in progress
 * UPDSTATE_Update_Start   Setting up, but no files have been modified
 * UPDSTATE_LFSStart       About to start processing all LFS file updates
 * UPDSTATE_ContentStart   About to start processing all Content file updates
 * UPDSTATE_IntegrateStart About to start processing a specific file
 * UPDSTATE_Integrating    Processing a file which integrates individual records
 * UPDSTATE_IntegrateEnd   Finished processing a specific file
 * UPDSTATE_LFSEnd         Finished processing all LFS file updates
 * UPDSTATE_ContentEnd     Finished processing all Content file updates
 * UPDSTATE_End            Finished processing all updates
 */
#define UPDSTATE_Default        1
#define UPDSTATE_Update_Start   2
#define UPDSTATE_LFSStart       3
#define UPDSTATE_ContentStart   4
#define UPDSTATE_IntegrateStart 5
#define UPDSTATE_Integrating    6
#define UPDSTATE_IntegrateEnd   7
#define UPDSTATE_LFSEnd         8
#define UPDSTATE_ContentEnd     9
#define UPDSTATE_End            10

/**
 ** type definitions
 **/

/* gn_upd_state is a type used to pass one of the UPDSTATE_<x> constants to
 * your callback function.
 */
typedef gn_uint32_t gn_upd_state;

/* gnupd_callback_t
 *
 *  Callback used for monitoring progress and servicing user abort requests.
 *
 *  Args
 *    state: IN: The state of the update process. See the UPDSTATE_* constants.
 *    record_count: IN: The ordinality of the record being processed for the
 *      current update file. This is only non-zero if the update state is
 *      UPDSTATE_Integrating. Most files are updated by simply installing a
 *      complete new update file. In thise cases, individual records are not
 *      processed, record_count is always 0 and the callback is never called
 *      with UPDSTATE_Integrating.
 *    record_total: IN: The total number of records to process for the current
 *      update file. Most files are updated by simply installing a complete new
 *      update file. In thise cases, individual records are not processed and
 *      record_total is always 0.
 *    file_counter: IN: The ordinality of the update file being processed.
 *    file_total: IN: The total number of update files to process.
 *
 *  Return value
 *    The abort callback function returns a boolean value.
 *    If set to GN_TRUE (do abort), the update will be terminted.
 *    If set to GN_FALSE, the update will continue.
 *
 * ABORTING AN UPDATE:
 *
 * If the update callback function returns GN_TRUE, then the update will be
 * terminated. In that case,
 *  - If you did not configure the library with the no_update_backups parameter
 *    set to GN_STR_TRUE, updates which have already been applied will be
 *    backed out for the LFS files and the Content files independently. Because
 *    LFS files are updated first, this means that if all LFS updates have been
 *    applied, i.e. the update state UPDSTATE_LFSEnd has already been reached or
 *    passed, the LFS updates will not be backed out. The advantage of this is
 *    that if you then try to reapply the update, the LFS updates will not need
 *    to be reprocessed.
 *  - If you did configure the library with the no_update_backups parameter set
 *    to GN_STR_TRUE, previously applied updates will be lost for the LFS and
 *    the Content files independently. Because LFS files are updated first, this
 *    means that if all LFS updates have been applied, i.e. the update state
 *    UPDSTATE_LFSEnd has already been reached or passed, those updates will not
 *    be lost. Note that if Content updates are lost, all previously applied
 *    update packages will need to be reapplied in order to restore the system
 *    to its optimal state. Because of this, if backups are not kept, you might
 *    consider not supporting the update abort feature.
 *    
 *    The backing out or removal of updates is done as described above to
 *    ensure that the system is left in a consistent state. In order to function
 *    properly
 *      all LFS files must have had the same updates applied
 *      all Content files must have had the same updates applied
 *      the Content updates must not be "ahead of" the LFS updates
 */
typedef	gn_bool_t (*gnupd_callback_t)(
	gn_upd_state state,
	gn_uint32_t  record_counter,
	gn_uint32_t  record_total,
	gn_uint32_t  file_counter,
	gn_uint32_t  file_total);

/**
 ** prototypes
 **/

/* gn_update_set_callback
 *
 *   Behavior: Set a user callback function to be called periodically during
 *             the update process. The callback can be used to monitor update
 *             progress and to communicate back to the eMMS library that the
 *             update should be terminated.
 *             Setting the callback function is optional. Updates will work
 *             without a callback set. A callback simply provides you with
 *             update status and a mechanism to abort an update in progress.
 *
 *   Args: IN: callback - Pointer to the user callback function.
 */
gn_error_t
gn_update_set_callback(
	gnupd_callback_t callback
);

/* gn_update_set_callback_period
 *
 *   Behavior: Set the period at which the callback function should be
 *             called. When updating a record based update file, the callback
 *             will be called after each "callback_period" records are added
 *             to the update file. If this function is not called, then a
 *             default value will be used.
 *
 *             Note, not all update files are record based. Some update files
 *             replace the original base file. The callback_period is not
 *             relevant for those files.
 *
 *             This function has no impact if a callback function was not set.
 *
 *             If the callback_period is set to 0, then the callback function
 *             will not be called while adding records to a specific update
 *             file. It will still be called each time the state changes, and
 *             just before starting each update file.
 *
 *   Args: IN: callback_period - The period in units of records added to
 *             the update file at which the callback should be called.
 */
gn_error_t
gn_update_set_callback_period(
	gn_uint32_t callback_period
);

/* gn_update_is_required
 *
 *   Behavior: This function takes the pathname to a local database update
 *             package. If the given update package contains updates which are
 *             not yet included in the local database then on successful return
 *             update_required will be GN_TRUE and the update package file
 *             should be applied via gn_update_apply_update().
 *
 *   Args: IN: package_file_name (required) - Filename, including any necessary
 *                path information, to the update package to query.
 *         OUT: update_required (required) - Upon successful return indicates
 *                whether you need to apply the update(s) in package_file_name.
 */
gn_error_t
gn_update_is_required(
	const gn_uchar_t* package_file_name,
	gn_bool_t*        update_required
);

/* gn_update_apply_update
 *
 *   Behavior: Applies necessary updates from the given update package file to
 *             the local database.
 *             Updates in the update package file which have previously been
 *             applied to the local database will not be applied again. They
 *             will be silently skipped.
 *
 *   Args: IN: package_file_name (required) - Filename, including any necessary
 *                path information, to the update package to apply.
 *
 *   NOTE: If gn_update_apply_update returns VALIDATEERR_InvalidDatabase a
 *         database corruption has been detected which prevents the application
 *         of the update. In this case, you should refer to the validation
 *         API declared in gn_validate.h for an indication of how to recover.
 *
 *         Other non-GN_SUCCESS error returns from gn_update_apply_update()
 *         indicate a failure which was not due to database corruption.
 */
gn_error_t
gn_update_apply_update(
	const gn_uchar_t* package_file_name
);

/* gn_update_backup
 *
 *  Behavior: Generates a backup copy of the update database files.
 *
 *            Normally this is done at the end of the application of an update.
 *            However, if the process is interrupted during the generation of
 *            the backup files, you may need to initiate the backup process
 *            "by hand" in order to reach a consistent state.
 *
 *            Calling this function after an update returns will have NO
 *            PRACTICAL EFFECT, whether or not the update returns GN_SUCCESS or
 *            an error value.
 */
gn_error_t
gn_update_backup(void);

/* gn_update_revert
 *
 *   Behavior: Revert the database to the state it was in just after the most
 *             recent successful update.
 *
 *             Each database file which is updated via the interface declared
 *             in this file has an associated update file. The update files are
 *             generated the first time an update is applied. Subsequent updates
 *             modify only the update files. The last step of the update process
 *             after all update files have been updated, is to make backup
 *             copies of the update files. So, at the end of a successful update
 *             there is a set of update files, each of which has an identical
 *             backup file. If the next update should be interrupted, the
 *             update files might be left in a corrupt state. In this case, you
 *             can call gn_update_revert() to fall back to the state after the
 *             previous, successful, update.
 *
 *             Note, it is possible to disable the generation of the update
 *             backup files via the configuration structure provided to the
 *             library initialization function, gninit_initialize_emms(). In
 *             this case, gn_update_revert() will simply delete the update
 *             files. You should only disable the generation of update backup
 *             files if disk space is extremely critical and you are willing to
 *             risk needing to reapply all updates if something goes wrong
 *             during an update or if the update files are otherwise corrupted.
 *
 *	           Calling this function if gn_update_apply_update() finishes,
 *             whether it returns GN_SUCCESS or an error value, will normally
 *             have NO PRACTICAL EFFECT. In the event that an error is
 *             returned, the update process will automatically revert to the
 *             backup files if necessary.
 */
gn_error_t
gn_update_revert(void);

/* gn_update_delete
 *
 *   Behavior: Delete the update and the update backup files, thereby returning
 *             the database to factory settings.
 *
 *             In the unlikely event that both the update and the update backup
 *             files are corrupt, it may be necessary to delete all update
 *             related files. In this case, all updates which have been applied
 *             will need to be reapplied in order to have the most current
 *             database. Because of this, issuing gn_update_delete() is a last
 *             resort. Prior to issuing gn_update_delete(), you may wish to
 *             provide additional analytics in the application.
 */
gn_error_t
gn_update_delete(void);

/* gn_update_recover
 *
 *   Behavior: Attempt to recover a corrupt local database. Recovery is guided
 *             by the validation argument. Before calling this function, you
 *             must create validation with gninit_initialize_emms_safe().
 *
 *   Args: IN: validation - A gn_validate_t structure which the application has
 *                created and populated. The action of gn_update_recover() is
 *                determined by this structure.
 *         OUT: The output arguments only have meaning if the function returns
 *              GN_SUCCESS.
 */
gn_error_t
gn_update_recover(
	const gn_validate_t* validation
);


#ifdef __cplusplus
}
#endif 

#endif /* _GN_UPDATER_H_ */

